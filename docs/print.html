<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>µGo语言实现</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="如何从头开发一个迷你Go语言编译器">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="book.html">µGo语言实现</a></li><li class="chapter-item expanded affix "><a href="preface.html">前言</a></li><li class="chapter-item expanded "><a href="ch1-basic/index.html"><strong aria-hidden="true">1.</strong> 基础</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch1-basic/ch1-01-ugo.html"><strong aria-hidden="true">1.1.</strong> µGo简介</a></li><li class="chapter-item expanded "><a href="ch1-basic/ch1-02-mini-compiler.html"><strong aria-hidden="true">1.2.</strong> 最小编译器</a></li><li class="chapter-item expanded "><a href="ch1-basic/ch1-03-llvm-ir.html"><strong aria-hidden="true">1.3.</strong> LLVM汇编简介</a></li></ol></li><li class="chapter-item expanded "><a href="ch2-expr/index.html"><strong aria-hidden="true">2.</strong> 表达式</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch2-expr/ch2-01-add-sub.html"><strong aria-hidden="true">2.1.</strong> 加减法表达式</a></li><li class="chapter-item expanded "><a href="ch2-expr/ch2-02-mul-div.html"><strong aria-hidden="true">2.2.</strong> 乘除法表达式</a></li><li class="chapter-item expanded "><a href="ch2-expr/ch2-03-parser.html"><strong aria-hidden="true">2.3.</strong> 解析表达式语法树</a></li><li class="chapter-item expanded "><a href="ch2-expr/ch2-04-parser-v2.html"><strong aria-hidden="true">2.4.</strong> 重构解析器</a></li></ol></li><li class="chapter-item expanded "><a href="ch3-hello-ugo/index.html"><strong aria-hidden="true">3.</strong> 最小µGo程序</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch3-hello-ugo/ch3-01.html"><strong aria-hidden="true">3.1.</strong> AST视角的µGo程序</a></li><li class="chapter-item expanded "><a href="ch3-hello-ugo/ch3-02.html"><strong aria-hidden="true">3.2.</strong> AST到LLVM汇编</a></li><li class="chapter-item expanded "><a href="ch3-hello-ugo/ch3-03.html"><strong aria-hidden="true">3.3.</strong> 完善词法解析器</a></li><li class="chapter-item expanded "><a href="ch3-hello-ugo/ch3-04.html"><strong aria-hidden="true">3.4.</strong> 完善语法解析器</a></li><li class="chapter-item expanded "><a href="ch3-hello-ugo/ch3-05.html"><strong aria-hidden="true">3.5.</strong> 打印AST语法树</a></li><li class="chapter-item expanded "><a href="ch3-hello-ugo/ch3-06.html"><strong aria-hidden="true">3.6.</strong> 命令行界面</a></li></ol></li><li class="chapter-item expanded "><a href="ch4-block-and-var/index.html"><strong aria-hidden="true">4.</strong> 变量和作用域</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch4-block-and-var/ch4-01.html"><strong aria-hidden="true">4.1.</strong> 完善token包</a></li><li class="chapter-item expanded "><a href="ch4-block-and-var/ch4-02.html"><strong aria-hidden="true">4.2.</strong> 完善AST和解析器</a></li><li class="chapter-item expanded "><a href="ch4-block-and-var/ch4-03.html"><strong aria-hidden="true">4.3.</strong> 完善LLIR输出</a></li><li class="chapter-item expanded "><a href="ch4-block-and-var/ch4-04.html"><strong aria-hidden="true">4.4.</strong> 输出WASM模块</a></li><li class="chapter-item expanded "><a href="ch4-block-and-var/ch4-05.html"><strong aria-hidden="true">4.5.</strong> 简短定义和多赋值</a></li></ol></li><li class="chapter-item expanded "><a href="ch5-if-for/index.html"><strong aria-hidden="true">5.</strong> if分支和for循环</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="ch5-if-for/ch5-01.html"><strong aria-hidden="true">5.1.</strong> 完善token包和lex包</a></li><li class="chapter-item expanded "><a href="ch5-if-for/ch5-02.html"><strong aria-hidden="true">5.2.</strong> 完善AST和解析器</a></li><li class="chapter-item expanded "><a href="ch5-if-for/ch5-03.html"><strong aria-hidden="true">5.3.</strong> if分支到LLIR汇编</a></li><li class="chapter-item expanded "><a href="ch5-if-for/ch5-04.html"><strong aria-hidden="true">5.4.</strong> for分支到LLIR汇编</a></li><li class="chapter-item expanded "><a href="ch5-if-for/ch5-05.html"><strong aria-hidden="true">5.5.</strong> 打印1到100的素数</a></li></ol></li><li class="chapter-item expanded "><a href="ch6-func/index.html"><strong aria-hidden="true">6.</strong> 函数和递归</a></li><li class="chapter-item expanded "><a href="ch7-pkgs-files/index.html"><strong aria-hidden="true">7.</strong> 多文件和多包支持</a></li><li class="chapter-item expanded "><a href="ch8-string/index.html"><strong aria-hidden="true">8.</strong> 字符串</a></li><li class="chapter-item expanded "><a href="ch9-array/index.html"><strong aria-hidden="true">9.</strong> 数组</a></li><li class="chapter-item expanded "><a href="ch10-map/index.html"><strong aria-hidden="true">10.</strong> map</a></li><li class="chapter-item expanded "><a href="ch11-struct/index.html"><strong aria-hidden="true">11.</strong> 结构体</a></li><li class="chapter-item expanded "><a href="ch12-method/index.html"><strong aria-hidden="true">12.</strong> 方法</a></li><li class="chapter-item expanded "><a href="ch13-closure/index.html"><strong aria-hidden="true">13.</strong> 闭包</a></li><li class="chapter-item expanded "><a href="ch14-interface/index.html"><strong aria-hidden="true">14.</strong> 接口</a></li><li class="chapter-item expanded "><a href="ch15-panic/index.html"><strong aria-hidden="true">15.</strong> 异常</a></li><li class="chapter-item expanded "><a href="ch16-reflect/index.html"><strong aria-hidden="true">16.</strong> 反射</a></li><li class="chapter-item expanded "><a href="ch17-cgo/index.html"><strong aria-hidden="true">17.</strong> CGO</a></li><li class="chapter-item expanded "><a href="ch18-wasm/index.html"><strong aria-hidden="true">18.</strong> WASM</a></li><li class="chapter-item expanded "><a href="ch19-type-system/index.html"><strong aria-hidden="true">19.</strong> 类型系统</a></li><li class="chapter-item expanded "><a href="ch20-bootstrap/index.html"><strong aria-hidden="true">20.</strong> 自举</a></li><li class="chapter-item expanded "><a href="ch21-lsp/index.html"><strong aria-hidden="true">21.</strong> LSP服务</a></li><li class="chapter-item expanded "><a href="appendix/index.html"><strong aria-hidden="true">22.</strong> 附录</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">µGo语言实现</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/chai2010/ugo-compiler-book" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="µgo语言实现从头开发一个迷你go语言编译器"><a class="header" href="#µgo语言实现从头开发一个迷你go语言编译器">µGo语言实现——从头开发一个迷你Go语言编译器</a></h1>
<p>本书尝试以实现 µGo 编译器为线索，以边学习边完善的自举方式实现一个玩具语言。</p>
<p><img src="cover.png" alt="" /></p>
<ul>
<li>仓库地址: <a href="https://chai2010.cn/ugo-compiler-book/">https://chai2010.cn/ugo-compiler-book/</a></li>
</ul>
<hr />
<ul>
<li><a href="https://github.com/chai2010/chai2010/blob/master/jobs.md">蚂蚁 - 可信原生技术部 - 云原生运维专家(杭州P7-8)</a></li>
<li><a href="https://github.com/chai2010/chai2010/blob/master/jobs.md">蚂蚁 - 可信原生技术部 - 专用编程语言设计研发(杭州P7-8)</a></li>
</ul>
<hr />
<h2 id="license-版权"><a class="header" href="#license-版权">License 版权</a></h2>
<p>学习目的可自由使用。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<h2 id="why-凹读音wa坑的起因"><a class="header" href="#why-凹读音wa坑的起因">Why: 凹(读音Wa)坑的起因</a></h2>
<ul>
<li>因为坑就在那里</li>
<li>不希望被Rxxx语言把脸摁在地上摩擦</li>
<li>凹坑的工具差不多齐全了</li>
<li>？</li>
</ul>
<h2 id="what-µgo-例子"><a class="header" href="#what-µgo-例子">What: µGo 例子</a></h2>
<pre><code class="language-go">package main

import &quot;libc&quot;
import m &quot;libc.math&quot;

const Pi = 3.14
const Pi_2 = Pi * 2

type MyInt int
type MyInt2 = int

var x = println(1 + 2*(3+4) + -10 + double(50))

func println() int

func main() int {}
</code></pre>
<h2 id="output-输出的目标格式"><a class="header" href="#output-输出的目标格式">Output: 输出的目标格式</a></h2>
<p>为了跨平台和方便测试，输出LLVM汇编代码，如果以后可能会增加WASM文件。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="1-基础"><a class="header" href="#1-基础">1. 基础</a></h1>
<p>本章简单介绍 µGo 特点、一个最简编译器、和LLVM-IR汇编基础。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-µgo简介"><a class="header" href="#11-µgo简介">1.1. µGo简介</a></h1>
<p>µGo 是迷你Go语言玩具版本，只保留最基本的int数据类型、变量定义和函数、分支和循环等最基本的特性。µGo 有以下的关键字：<code>var</code>、<code>func</code>、<code>if</code>、<code>for</code>、<code>return</code>。此外有一个<code>int</code>内置的数据类型，<code>func input() int</code> 函数读取一个整数，<code>println(...)</code> 打印函数。</p>
<p>比如计算1到100的和对应以下代码：</p>
<pre><code class="language-go">func main() {
	var sum int
	for i := 0; i &lt;= 100; i = i+1 {
		sum = sum+1
	}
	println(sum)
}
</code></pre>
<p>µGo 的具体定义会根据需要和实现的情况调整，目前可以将其作为Go的最小子集就可。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-最小编译器"><a class="header" href="#12-最小编译器">1.2. 最小编译器</a></h1>
<p>我们先从最小的整数开始，每个整数表示一个返回该值状态码的程序。</p>
<p>比如 0 表示 <code>os.Exit(0)</code>。它对应以下的Go程序：</p>
<pre><code class="language-go">package main;

import &quot;os&quot;

func main() {
	os.Exit(0)
}
</code></pre>
<p>对应以下的LLVM-IR代码:</p>
<pre><code class="language-ll">define i32 @main() {
	ret i32 0
}
</code></pre>
<p>入口是<code>@main</code>函数，<code>ret</code>指令返回i32类型的0。</p>
<p>可以通过以下命令编译并执行这个汇编程序：</p>
<pre><code>$ clang -o a.out _main.ll
$ ./a.out
$ echo $?
0
</code></pre>
<p>clang 将汇编程序编译为本地可执行程序，然后执行 a.out 程序，最后通过shell的 <code>echo $?</code> 命令查看 a.out 的退出状态码。</p>
<p>最小编译器就是将输入的整数翻译为可执行程序的返回该状态码的本地程序：</p>
<pre><code class="language-go">func compile(code string) {
	output := fmt.Sprintf(tmpl, code)
	os.WriteFile(&quot;a.out.ll&quot;, []byte(output), 0666)
	exec.Command(&quot;clang&quot;, &quot;-Wno-override-module&quot;, &quot;-o&quot;, &quot;a.out&quot;, &quot;a.out.ll&quot;).Run()
}

const tmpl = `
define i32 @main() {
	ret i32 %v
}
`
</code></pre>
<p>其中 compile 是编译函数，将从stdin输入的代码先编译为汇编程序，然后调用clang将汇编程序编译为本地可执行程序（<code>tmpl</code>是输出汇编的模板）。</p>
<p>通过以下命令将输入的状态码编译为一个对应的可执行程序：</p>
<pre><code class="language-shell">$ echo 123 | go run main.go
$ ./a.out
$ echo $?
123
</code></pre>
<p>这样我们就实现了一个只能编译整数到本地可执行程序的最小编译器。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-llvm汇编简介"><a class="header" href="#13-llvm汇编简介">1.3. LLVM汇编简介</a></h1>
<p>LLVM是低级虚拟机，其对应的指令可以看做是一种低级跨平台汇编语言（LLVM IR 是一种 SSA静态单赋值语言）。本节我们简单介绍LLVM汇编语言。</p>
<h2 id="最简汇编程序"><a class="header" href="#最简汇编程序">最简汇编程序</a></h2>
<p>最小编译器的例子我们见识过最简LLVM汇编程序：</p>
<pre><code class="language-ll">; hello.ll
define i32 @main() {
	ret i32 42
}
</code></pre>
<p><code>;</code>开始的是行注释，注明了汇编程序文件为 <code>hello.ll</code>。define 定义一个 <code>@main</code> 函数，函数返回值是 i32 类型。<code>@main</code>函数的实现只有一个ret返回语句，返回 i32 类型的 42。</p>
<p>通过以下命令编译为可执行程序、并执行和查看返回值：</p>
<pre><code class="language-shell">$ clang hello.ll
warning: overriding the module target triple with x86_64-apple-macosx10.15.4 [-Woverride-module]
1 warning generated.
$ ./a.out
$ echo $?
42
</code></pre>
<p>其中clang命令输出了一个警告信息：表示该LLVM程序没有指定目标平台，因此用本地环境覆盖了。警告错误中的 <code>x86_64-apple-macosx10.15.4</code> 为 LLVM 到目标三元组，第一个 <code>x86_64</code> 表示 CPU 类型、第二个 <code>apple</code> 表示操作系统类型、第三个 <code>macosx10.15.4</code> 操作系统版本信息。我们可以通过给 clang 添加 <code>-Wno-override-module</code> 命令行参数关闭该警告信息（在汇编程序中添加 <code>target triple = &quot;x86_64-apple-macosx10.15.4&quot;</code>也可以，不过汇编程序就绑死了目标平台）。</p>
<h2 id="打印加减法结果"><a class="header" href="#打印加减法结果">打印加减法结果</a></h2>
<p>要实现加减法运算，可以通过LLVM的add和sub指令完成：</p>
<pre><code class="language-ll">define i32 @main() {
	%x1 = add i32 1, 3
	%x2 = sub i32 %x1, 2
	ret i32 %x2 ; 1+3-2
}
</code></pre>
<p>其中 add 和 sub 分别做减法和减法，指令后面跟着的3个参数分别是 类型、二元操作数。返回的结果依然可以通过 <code>echo $?</code> 方式查看，不过需要注意到是 shell 只支持 0-255 范围内的返回值。</p>
<p>如果要直接输出运算结果，可以借助 C语言的 <code>@printf</code> 函数完成：</p>
<pre><code class="language-ll">declare i32 @printf(i8*,...)

@format = constant [4 x i8] c&quot;%d\0A\00&quot;

define i32 @main() {
	; 1 + 3 - 2
	%x1 = add i32 1, 3
	%x2 = sub i32 %x1, 2

	; printf(&quot;%d\n&quot;, x2)
	call i32(i8*,...) @printf(i8* getelementptr([4 x i8], [4 x i8]* @format, i32 0, i32 0), i32 %x2)

	ret i32 0
}
</code></pre>
<p>首先通过 declare 指令从外部导入 <code>@printf</code> 函数。然后定义 <code>@format</code> 字符串常量 <code>&quot;%d\n&quot;</code>，用于 printf 函数的第一个参数（其中<code>%d</code>表示输出一个整数）。call 指令调用<code>@printf</code>打印函数输出<code>%x2</code>的值，其中 <code>getelementptr</code> 是将 <code>@format</code> 转为 <code>i8*</code>类型的指针传入第一个参数，第二个参数是 i32 类型的 <code>%x2</code>。</p>
<h2 id="程序结构"><a class="header" href="#程序结构">程序结构</a></h2>
<p>LLVM汇编程序的结构大同小异，最开始是目标三元组（可省略）：</p>
<pre><code class="language-ll">target triple = &quot;x86_64-pc-linux-gnu&quot;
</code></pre>
<p>然后是导入的和本地定义的函数、类型、常量、变量等：</p>
<pre><code class="language-ll">; 声明 puts 函数
declare i32 @puts(i8*)

; 定义常量字符串
@msg = constant [14 x i8] c&quot;Hello, world!\00&quot;
</code></pre>
<p>最后是全局函数的定义：</p>
<pre><code class="language-ll">define i32 @main() {
entry:
	call i32(i8*) @puts(i8* getelementptr([14 x i8], [14 x i8]* @msg, i32 0, i32 0))
	ret i32 0
}
</code></pre>
<p>这里的main函数通过外部的C语言puts函数输出一个“Hello, world!”字符串。</p>
<h2 id="小结"><a class="header" href="#小结">小结</a></h2>
<p>LLVM IR 是一种 SSA静态单赋值语言，因此每个名称在您的程序中只能被分配一次。全局名称以 @开头，通常用于全局常量或函数名称，例如 @main。在每个函数中使用局部寄存器名称，这些名称以%开头（这些并不是真正的寄存器，因此数量并无限制）。</p>
<p>LLVM的常见类型：</p>
<ul>
<li>i1：1位整数，可以用于分支判断的条件</li>
<li>i8：8为整数，对应 byte 类型</li>
<li>i32：32位整数</li>
<li>i64：64位整数</li>
<li><code>[N x type]</code>：长度为N，类似是type的数组，比如 <code>@format = constant [4 x i8] c&quot;%d\0A\00&quot;</code> 对应 <code>[4]int8</code> 类型数组。</li>
<li><code>type*</code>：指向type类型的指针</li>
<li><code>type(types)</code>：函数类型，type是函数返回值类型，types是参数的类型。比如 main 函数可能是 <code>i32()</code> 或 <code>i32(i32,i8**)</code> 类型。</li>
</ul>
<p>每个 LLVM IR 函数内的指令被分组为基本块或普通指令。每个基本块都可以选择以一个标签开头（如果只有一个块则可以省略）。并且每个基本块都必须以特殊的“终止符指令”结尾（比如 br 、ret等指令）。每个基本块标签也对应一个虚拟寄存器，可以通过<code>%label</code>访问其对应的地址。</p>
<p>LLVM 语言参考在这里：https://llvm.org/docs/LangRef.html</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="2-表达式"><a class="header" href="#2-表达式">2. 表达式</a></h1>
<p>表达式是编程语言中大家最熟悉部分，我们先从将表达式翻译为LLVM-IR开始。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-加减法表达式"><a class="header" href="#21-加减法表达式">2.1. 加减法表达式</a></h1>
<p>在前一节我们通过最小编译器将一个整数编译为可以返回相同状态码的程序。现在我们尝试将加法和减法的表达式编译为同样的程序。</p>
<p>比如有 <code>1+3-2</code> 表达式，手工编写对应的LLVM汇编程序如下：</p>
<pre><code class="language-ll">define i32 @main() {
	; 1 + 3 - 2
	%t0 = add i32 0, 1   ; t0 = 1
	%t1 = add i32 %t0, 3 ; t1 = t0 + 3
	%t2 = sub i32 %t1, 2 ; t2 = t1 - 2
	ret i32 %t2
}
</code></pre>
<p>如果将输入的<code>1+3-2</code>转化为<code>[]string{&quot;1&quot;, &quot;+&quot;, &quot;3&quot;, &quot;-&quot;, &quot;2&quot;}</code> 形式，我们则可以通过以下代码输出对应的汇编程序：</p>
<pre><code class="language-go">func gen_asm(tokens []string) string {
	var buf bytes.Buffer
	fmt.Fprintln(&amp;buf, `define i32 @main() {`)

	var idx int
	for i, tok := range tokens {
		if i == 0 {
			fmt.Fprintf(&amp;buf, &quot;\t%%t%d = add i32 0, %v\n&quot;,
				idx, tokens[i],
			)
			continue
		}
		switch tok {
		case &quot;+&quot;:
			idx++
			fmt.Fprintf(&amp;buf, &quot;\t%%t%d = add i32 %%t%d, %v\n&quot;,
				idx, idx-1, tokens[i+1],
			)
		case &quot;-&quot;:
			idx++
			fmt.Fprintf(&amp;buf, &quot;\t%%t%d = sub i32 %%t%d, %v\n&quot;,
				idx, idx-1, tokens[i+1],
			)
		}
	}
	fmt.Fprintf(&amp;buf, &quot;\tret i32 %%t%d\n&quot;, idx)
	fmt.Fprintln(&amp;buf, `}`)

	return buf.String()
}
</code></pre>
<p>而如何将输入的字符串拆分为记号数组本质上属于词法分析的问题。我们先以最简单的方式实现：</p>
<pre><code class="language-go">func parse_tokens(code string) (tokens []string) {
	for code != &quot;&quot; {
		if idx := strings.IndexAny(code, &quot;+-&quot;); idx &gt;= 0 {
			if idx &gt; 0 {
				tokens = append(tokens, strings.TrimSpace(code[:idx]))
			}
			tokens = append(tokens, code[idx:][:1])
			code = code[idx+1:]
			continue
		}

		tokens = append(tokens, strings.TrimSpace(code))
		return
	}
	return
}
</code></pre>
<p>基本思路是通过 <code>strings.IndexAny(code, &quot;+-&quot;)</code> 函数调用根据 <code>+-</code> 符号拆分，最终返回拆分后的词法列表。</p>
<p>然后对上个版本的compile函数稍加改造以支持加法和减法的运算表达式编译：</p>
<pre><code class="language-go">func compile(code string) {
	tokens := parse_tokens(code)
	output := gen_asm(tokens)

	os.WriteFile(&quot;a.out.ll&quot;, []byte(output), 0666)
	exec.Command(&quot;clang&quot;, &quot;-Wno-override-module&quot;, &quot;-o&quot;, &quot;a.out&quot;, &quot;a.out.ll&quot;).Run()
}
</code></pre>
<p>为了便于测试，我们再包装一个run函数：</p>
<pre><code class="language-go">func run(code string) int {
	compile(code)
	if err := exec.Command(&quot;./a.out&quot;).Run(); err != nil {
		return err.(*exec.ExitError).ExitCode()
	}
	return 0
}
</code></pre>
<p>run函数将输入的表达式程序编译并运行、最后返回状态码。然后构造单元测试：</p>
<pre><code class="language-go">func TestRun(t *testing.T) {
	for i, tt := range tests {
		if got := run(tt.code); got != tt.value {
			t.Fatalf(&quot;%d: expect = %v, got = %v&quot;, i, tt.value, got)
		}
	}
}

var tests = []struct {
	code  string
	value int
}{
	{code: &quot;1&quot;, value: 1},
	{code: &quot;1+1&quot;, value: 2},
	{code: &quot;1 + 3 - 2  &quot;, value: 2},
	{code: &quot;1+2+3+4&quot;, value: 10},
}
</code></pre>
<p>确认单元测试没有问题后，更新main函数：</p>
<pre><code class="language-go">func main() {
	code, _ := io.ReadAll(os.Stdin)
	fmt.Println(run(string(code)))
}
</code></pre>
<p>通过以下命令执行：</p>
<pre><code>$ echo &quot;1+2+3&quot; | go run main.go 
6
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="22-乘除法表达式"><a class="header" href="#22-乘除法表达式">2.2. 乘除法表达式</a></h1>
<p>这节我们在加减表达式基础之上增加乘除和小括弧的支持。在开始之前我们先对比下加减表达式和可乘除的表达式的本质区别。</p>
<p>因为加减表达式只有一种优先级，可以从左到右依次在当前结果的基础上计算出每一步的结果，因此只需要一个寄存器表示中间结果即可。如果基于有限数量的寄存器进行任意的加减乘除运算则可能需要借助栈保存中间结果。不过LLVM是一个SSA静态单赋值的抽象汇编语言，其虚拟的寄存器数量是无限的，因此只要处理好乘除法的优先级就可以轻松完成任意的加减乘除表达式运算。</p>
<p>为了简化，我们先假设输入的表达式已经根据优先级被转化为树形结构。比如 <code>1+2*(3+4)</code> 对应以下的树形结构：</p>
<pre><code>  +
 / \
1   *
   / \
  2   +
     / \
    3   4
</code></pre>
<p>这个表达式语法树类似普通的二叉树，节点中的值对应表达式的运算符或整数。我们可以单采用以下的结构表示：</p>
<pre><code class="language-go">type ExprNode struct {
	Value string // +, -, *, /, 123
	Left  *ExprNode
	Right *ExprNode
}

var expr = &amp;ExprNode{
	Value: &quot;+&quot;,
	Left: &amp;ExprNode{
		Value: &quot;1&quot;,
	},
	Right: &amp;ExprNode{
		Value: &quot;*&quot;,
		Left: &amp;ExprNode{
			Value: &quot;2&quot;,
		},
		Right: &amp;ExprNode{
			Value: &quot;+&quot;,
			Left:  &amp;ExprNode{
				Value: &quot;3&quot;,
			},
			Right:  &amp;ExprNode{
				Value: &quot;4&quot;,
			},
		},
	},
}
</code></pre>
<p>现在可以构造针对ExprNode的 Compiler 对象：</p>
<pre><code class="language-go">type Compiler struct {
	nextId int
}

func (p *Compiler) GenLLIR(node *ExprNode) string {
	var buf bytes.Buffer
	fmt.Fprintf(&amp;buf, &quot;define i32 @main() {\n&quot;)
	fmt.Fprintf(&amp;buf, &quot;    ret i32 %s\n&quot;, p.genValue(&amp;buf, node))
	fmt.Fprintf(&amp;buf, &quot;}\n&quot;)

	return buf.String()
}

func (p *Compiler) genId() string {
	id := fmt.Sprintf(&quot;%%t%d&quot;, p.nextId)
	p.nextId++
	return id
}
</code></pre>
<p>其中 GenLLIR 方法用于将 node 翻译为一个LLVM汇编语言，表达式的终极节点通过<code>p.genValue(&amp;buf, node)</code>完成编译。此外还有一个genId辅助方法用于生成唯一的局部虚拟寄存器名字。</p>
<p>genValue 的实现如下：</p>
<pre><code class="language-go">func (p *Compiler) genValue(w io.Writer, node *ExprNode) (id string) {
	if node == nil {
		return &quot;&quot;
	}
	id = p.genId()
	switch node.Value {
	case &quot;+&quot;:
		fmt.Fprintf(w, &quot;\t%s = add i32 %s, %s\n&quot;,
			id, p.genValue(w, node.Left), p.genValue(w, node.Right),
		)
	case &quot;-&quot;:
		fmt.Fprintf(w, &quot;\t%s = sub i32 %s, %s\n&quot;,
			id, p.genValue(w, node.Left), p.genValue(w, node.Right),
		)
	case &quot;*&quot;:
		fmt.Fprintf(w, &quot;\t%s = mul i32 %s, %s\n&quot;,
			id, p.genValue(w, node.Left), p.genValue(w, node.Right),
		)
	case &quot;/&quot;:
		fmt.Fprintf(w, &quot;\t%s = sdiv i32 %s, %s\n&quot;,
			id, p.genValue(w, node.Left), p.genValue(w, node.Right),
		)
	default:
		fmt.Fprintf(w, &quot;\t%[1]s = add i32 0, %[2]s; %[1]s = %[2]s\n&quot;,
			id, node.Value,
		)
	}
	return
}
</code></pre>
<p>如果<code>node.Value</code>是加减乘除运算符，则递归编译左右子树并产生新的结果，如果不是运算符则作为数值直接返回（通过将数值和0相加产生一个值）。</p>
<p>包装main函数执行对表达式的翻译：</p>
<pre><code class="language-go">func main() {
	result := run(expr) // 1+2*(3+4)
	fmt.Println(result)
}
</code></pre>
<p>运行代码将得到以下的LLVM汇编：</p>
<pre><code class="language-ll">define i32 @main() {
	%t1 = add i32 0, 1; %t1 = 1
	%t3 = add i32 0, 2; %t3 = 2
	%t5 = add i32 0, 3; %t5 = 3
	%t6 = add i32 0, 4; %t6 = 4
	%t4 = add i32 %t5, %t6
	%t2 = mul i32 %t3, %t4
	%t0 = add i32 %t1, %t2
	ret i32 %t0
}
</code></pre>
<p>这样就完成了表达式树到LLVM汇编的翻译。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="23-解析表达式语法树"><a class="header" href="#23-解析表达式语法树">2.3. 解析表达式语法树</a></h1>
<p>要生成语法树需要将代码的字符序列转化为词法序列，然后再将词法序列解析为结构化的语法树。本节将开发一个简易版本的词法解析器，然后在此基础之上开发一个语法解析器，最终产生前一节的语法树。</p>
<h2 id="231-词法解析"><a class="header" href="#231-词法解析">2.3.1 词法解析</a></h2>
<p>在加法和减法表达式的例子我们已经实现了一个词法解析器，现在我们继续添加对<code>*/()</code>的解析支持。词法解析器一般叫lexer，我们新的函数改名为lex：</p>
<pre><code class="language-go">func Lex(code string) (tokens []string) {
	for code != &quot;&quot; {
		if idx := strings.IndexAny(code, &quot;+-*/()&quot;); idx &gt;= 0 {
			if idx &gt; 0 {
				tokens = append(tokens, strings.TrimSpace(code[:idx]))
			}
			tokens = append(tokens, code[idx:][:1])
			code = code[idx+1:]
			continue
		}

		tokens = append(tokens, strings.TrimSpace(code))
		return
	}
	return
}
</code></pre>
<p>其中<code>strings.IndexAny</code>增加了乘除法和小括弧的支持。目前我们暂时忽略错误的输入。开发调试的同时可以添加测试代码，如下：</p>
<pre><code class="language-go">func TestLex(t *testing.T) {
	var tests = []struct {
		input  string
		tokens []string
	}{
		{&quot;1&quot;, []string{&quot;1&quot;}},
		{&quot;1+22*333&quot;, []string{&quot;1&quot;, &quot;+&quot;, &quot;22&quot;, &quot;*&quot;, &quot;333&quot;}},
		{&quot;1+22*(3+4)&quot;, []string{&quot;1&quot;, &quot;+&quot;, &quot;22&quot;, &quot;*&quot;, &quot;(&quot;, &quot;3&quot;, &quot;+&quot;, &quot;4&quot;, &quot;)&quot;}},
	}
	for i, tt := range tests {
		if got := Lex(tt.input); !reflect.DeepEqual(got, tt.tokens) {
			t.Fatalf(&quot;%d: expect = %v, got = %v&quot;, i, tt.tokens, got)
		}
	}
}
</code></pre>
<p>目前的词法解析器虽然简陋，有了单元测试后面就可以放心重构和优化。词法解析可以参考Rob Pike的报告：https://talks.golang.org/2011/lex.slide。</p>
<h2 id="232-语法定义"><a class="header" href="#232-语法定义">2.3.2 语法定义</a></h2>
<p>语法解析和词法解析输入类似：前者是字符序列、后者是Token序列。输出的结果少有差异：词法解析器产生的是Token扁平的序列，而语法解析产生的是结构化的语法树。</p>
<p>目前依然复用之前的语法树结构：</p>
<pre><code class="language-go">type ExprNode struct {
	Value string    // +, -, *, /, 123
	Left  *ExprNode `json:&quot;,omitempty&quot;`
	Right *ExprNode `json:&quot;,omitempty&quot;`
}

func NewExprNode(value string, left, right *ExprNode) *ExprNode {
	return &amp;ExprNode{
		Value: value,
		Left:  left,
		Right: right,
	}
}
</code></pre>
<p>为了便于JSON打印，我们忽略了空指针。同时增加了NewExprNode构造函数。</p>
<p>在解析语法之前需要明确定义语法规则，下面是EBNF表示的四则运算规则：</p>
<pre><code class="language-bnf">expr    = mul (&quot;+&quot; mul | &quot;-&quot; mul)*
mul     = primary (&quot;*&quot; primary | &quot;/&quot; primary)*
primary = num | &quot;(&quot; expr &quot;)&quot;
</code></pre>
<p>可以将EBNF看作是正则表达式的增强版本，其中<code>|</code>表示或、<code>()</code>表示组合、<code>*</code>表示0或多个。比如 expr 规则表示了由 mul 表示的乘法元素再次通过加法或减法组合（隐含了乘法有更高的优先级）。mul 则定义了如何通过 primary 实现乘法或除法组合。而 primary 则表示更小更不可分的数字或小括弧包含的表达式元素。</p>
<h2 id="233-手工递归下降解析"><a class="header" href="#233-手工递归下降解析">2.3.3 手工递归下降解析</a></h2>
<p>有了EBNF参考之后我们就可以很容易手写一个递归下降的解析程序。手写定义一个parser解析器对象，其中包含词法序列和当前处理的pos位置。</p>
<pre><code class="language-go">type parser struct {
	tokens []string
	pos    int
}

func (p *parser) peekToken() string {
	if p.pos &gt;= len(p.tokens) {
		return &quot;&quot;
	}
	return p.tokens[p.pos]
}
func (p *parser) nextToken() {
	if p.pos &lt; len(p.tokens) {
		p.pos++
	}
}
</code></pre>
<p>同时也定义了2个辅助方法：peekToken预取下个元素，nextToken则是移动到下个元素。</p>
<p>然后参考3个规则定义3个有着相同结构的递归函数，每个函数递归构造出语法树：</p>
<pre><code class="language-go">func (p *parser) build_expr() *ExprNode {
	node := p.build_mul()
	for {
		switch p.peekToken() {
		case &quot;+&quot;:
			p.nextToken()
			node = NewExprNode(&quot;+&quot;, node, p.build_mul())
		case &quot;-&quot;:
			p.nextToken()
			node = NewExprNode(&quot;-&quot;, node, p.build_mul())
		default:
			return node
		}
	}
}
func (p *parser) build_mul() *ExprNode {
	node := p.build_primary()
	for {
		switch p.peekToken() {
		case &quot;*&quot;:
			p.nextToken()
			node = NewExprNode(&quot;*&quot;, node, p.build_primary())
		case &quot;/&quot;:
			p.nextToken()
			node = NewExprNode(&quot;/&quot;, node, p.build_primary())
		default:
			return node
		}
	}
}
func (p *parser) build_primary() *ExprNode {
	if tok := p.peekToken(); tok == &quot;(&quot; {
		p.nextToken()
		node := p.build_expr()
		p.nextToken() // skip ')'
		return node
	} else {
		p.nextToken()
		return NewExprNode(tok, nil, nil)
	}
}
</code></pre>
<p>然后再包装一个ParseExpr函数：</p>
<pre><code class="language-go">func ParseExpr(tokens []string) *ExprNode {
	p := &amp;parser{tokens: tokens}
	return p.build_expr()
}
</code></pre>
<p>然后可以构造一个例子测试语法树的解析：</p>
<pre><code class="language-go">func main() {
	// 1+2*(3+4)
	expr_tokens := []string{&quot;1&quot;, &quot;+&quot;, &quot;2&quot;, &quot;*&quot;, &quot;(&quot;, &quot;3&quot;, &quot;+&quot;, &quot;4&quot;, &quot;)&quot;}

	ast := ParseExpr(expr_tokens)
	fmt.Println(JSONString(ast))
}

func JSONString(x interface{}) string {
	d, _ := json.MarshalIndent(x, &quot;&quot;, &quot;    &quot;)
	return string(d)
}
</code></pre>
<p>输出的JSON如下：</p>
<pre><code class="language-json">{
    &quot;Value&quot;: &quot;+&quot;,
    &quot;Left&quot;: {
        &quot;Value&quot;: &quot;1&quot;
    },
    &quot;Right&quot;: {
        &quot;Value&quot;: &quot;*&quot;,
        &quot;Left&quot;: {
            &quot;Value&quot;: &quot;2&quot;
        },
        &quot;Right&quot;: {
            &quot;Value&quot;: &quot;+&quot;,
            &quot;Left&quot;: {
                &quot;Value&quot;: &quot;3&quot;
            },
            &quot;Right&quot;: {
                &quot;Value&quot;: &quot;4&quot;
            }
        }
    }
}
</code></pre>
<p>然后结合前一节的AST到LLVM的编译函数就可以实现表达式到可执行程序的翻译了。</p>
<h2 id="234-goyacc等工具"><a class="header" href="#234-goyacc等工具">2.3.4 goyacc等工具</a></h2>
<p>其实在Go1.5之前都是基于goyacc工具来产生编译器，在最初的版本我们也提供了基于goyacc的例子（代码还在仓库）。但是对于新手来说，并不推荐goyacc和AntLR等自动生成解析器代码的工具，因此删除了这部分内容。首先是手写解析器对于Go这种语法比较规则的语言并不困难，手写代码不仅仅可以熟悉解析器的工作模式，也可以为错误处理带来更大的灵活性。正如Rob Pike所言，我们也不建议通过goyacc自动生成代码的迂回战术、而是要手写解析器的方式迎头而上解决问题。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="24-重构解析器"><a class="header" href="#24-重构解析器">2.4. 重构解析器</a></h1>
<p>在前面的例子中，我们直接用string表示了词法记号。但是这样有一些问题：比如关键字“if”和“abc”变量名的类型就不好区分，同时词法记号的位置信息也丢失了。常见做法是将词法记号定义为一个int区分的类别，同时词法记号还携带一个原始字符串表示的面值（比如一个相同值到整数可能有不同的写法），同时再辅助一些位置信息。</p>
<h2 id="241-定义词法结构"><a class="header" href="#241-定义词法结构">2.4.1 定义词法结构</a></h2>
<p>重新定义词法结构如下：</p>
<pre><code class="language-go">// 词法记号类型
type TokenType int

// 记号值
type Token struct {
	Type TokenType // 记号类型
	Val  string  // 记号原始字面值
	Pos  int     // 开始位置
}

// 记号类型
const (
	EOF TokenType = iota
	ADD // +
	SUB // -
	MUL // *
	DIV // /

	LPAREN // (
	RPAREN // )
)
</code></pre>
<p>每个记号类型配有一个二元表达式的优先级(其中0表示不是二元运算符)：</p>
<pre><code class="language-go">func (op TokenType) Precedence() int {
	switch op {
	case ADD, SUB:
		return 1
	case MUL, DIV:
		return 2
	}
	return 0
}
</code></pre>
<p>同时提供一些辅助函数：</p>
<pre><code class="language-go">func (t lexType) String() string {
	switch t {
	case EOF:
		return &quot;EOF&quot;
	// ...
	default:
		return &quot;UNKNWON&quot;
	}
}

func (t Token) String() string {
	return fmt.Sprintf(&quot;Token(%v:%v)&quot;, t.Type, t.Val)
}
</code></pre>
<h2 id="242-定义语法树结构"><a class="header" href="#242-定义语法树结构">2.4.2 定义语法树结构</a></h2>
<p>词法定义从string变化为Token，AST结构调整如下：</p>
<pre><code class="language-go">type ExprNode struct {
	Token           // +, -, *, /, 123
	Left  *ExprNode `json:&quot;,omitempty&quot;`
	Right *ExprNode `json:&quot;,omitempty&quot;`
}

func NewExprNode(token Token, left, right *ExprNode) *ExprNode {
	return &amp;ExprNode{
		Token: token,
		Left:  left,
		Right: right,
	}
}
</code></pre>
<p>现在的Token包含了完整的信息，对应每个终结字符。</p>
<h2 id="243-词法解析器重构"><a class="header" href="#243-词法解析器重构">2.4.3 词法解析器重构</a></h2>
<p>有了Token结构之后，我们只需要将输入到代码字符串解析为Token序列即可。之前的词法是通过<code>strings.IndexAny</code>做分词，现在我们改用<code>text/scanner</code>包来辅助解析：</p>
<pre><code class="language-go">func Lex(code string) (tokens []Token) {
	var s scanner.Scanner
	s.Init(strings.NewReader(code))
	for x := s.Scan(); x != scanner.EOF; x = s.Scan() {
		var tok = Token{
			Val: s.TokenText(),
			Pos: s.Pos().Offset,
		}
		switch x {
		case scanner.Int:
			tok.Type = NUMBER
		default:
			switch s.TokenText() {
			case &quot;+&quot;:
				tok.Type = ADD
			case &quot;-&quot;:
				tok.Type = SUB
			case &quot;*&quot;:
				tok.Type = MUL
			case &quot;/&quot;:
				tok.Type = DIV
			case &quot;(&quot;:
				tok.Type = LPAREN
			case &quot;)&quot;:
				tok.Type = RPAREN
			default:
				tok.Type = ILLEGAL
				tokens = append(tokens, tok)
				return
			}
		}

		tokens = append(tokens, tok)
	}

	tokens = append(tokens, Token{Type: EOF})
	return
}
</code></pre>
<p><code>scanner.Scanner</code>可以解析常见的词法，我们只提取表达式需要的整数、四则运算和小括弧，其他类型记号用<code>ILLEGAL</code>表示无效值。</p>
<p><code>scanner.Scanner</code>对于解析真正的Go代码是稍显不足的。不过词法解析是相对容易实现的工作，大家可以选择自己喜欢的方式实现，甚至直接参考Go的<code>go/token</code>和<code>go/scanner</code>包也可以。</p>
<h2 id="244-token流读取器"><a class="header" href="#244-token流读取器">2.4.4 Token流读取器</a></h2>
<p>有了<code>Lex</code>函数之后我们就可以将代码转换为扁平的<code>Token</code>序列，然后在此基础之上通过语法解析器构造结构化的语法树。为了简化解析器的工作，我们再包装一个Token流读取器。</p>
<pre><code class="language-go">type TokenReader struct {
	tokens []Token
	pos    int
	width  int
}

func NewTokenReader(input []Token) *TokenReader {
	return &amp;TokenReader{tokens: input}
}
</code></pre>
<p>NewTokenReader 函数构造Token流读取器。</p>
<p>然后提供最常用的Peek、Read、Unread等类似的方法：</p>
<pre><code class="language-go">func (p *TokenReader) PeekToken() Token {
	tok := p.ReadToken()
	p.UnreadToken()
	return tok
}

func (p *TokenReader) ReadToken() Token {
	if p.pos &gt;= len(p.tokens) {
		p.width = 0
		return Token{Type: EOF}
	}
	tok := p.tokens[p.pos]
	p.width = 1
	p.pos += p.width
	return tok
}

func (p *TokenReader) UnreadToken() {
	p.pos -= p.width
	return
}
</code></pre>
<p>为了方便解析器工作，再定义 AcceptToken、MustAcceptToken两个方法：</p>
<pre><code class="language-go">func (p *TokenReader) AcceptToken(expectTypes ...TokenType) (tok Token, ok bool) {
	tok = p.ReadToken()
	for _, x := range expectTypes {
		if tok.Type == x {
			return tok, true
		}
	}
	p.UnreadToken()
	return tok, false
}

func (p *TokenReader) MustAcceptToken(expectTypes ...TokenType) (tok Token) {
	tok, ok := p.AcceptToken(expectTypes...)
	if !ok {
		panic(fmt.Errorf(&quot;token.Reader.MustAcceptToken(%v) failed&quot;, expectTypes))
	}
	return tok
}
</code></pre>
<p>AcceptToken方法可以用于适配可选的Token符号，比如if之后可选的else可以用<code>if _, ok := r.AcceptToken(token.ELSE); ok { ... }</code>方式处理。而MustAcceptToken则必须匹配相应的Token，比如<code>t.MustAcceptToken(token.RPAREN)</code>强制匹配右小括弧。</p>
<h2 id="245-二元表达式解析简化"><a class="header" href="#245-二元表达式解析简化">2.4.5 二元表达式解析简化</a></h2>
<p>BNF语法可以实现表达式的多优先级支持，比如前面支持加减乘除四则运算的EBNF如下：</p>
<pre><code class="language-bnf">expr    = mul (&quot;+&quot; mul | &quot;-&quot; mul)*
mul     = primary (&quot;*&quot; primary | &quot;/&quot; primary)*
primary = num | &quot;(&quot; expr &quot;)&quot;
</code></pre>
<p>其中通过引入mul和primary规则来表示2个不同的优先级。而Go语言的二元表达式有<code>||</code>、<code>&amp;&amp;</code>、<code>==</code>、<code>+</code>和<code>*</code>等5中不同的优先级。如果完全通过EBNF来表示优先级则需要构造更为复杂的规则：</p>
<pre><code class="language-bnf">expr       = logic_or
logic_or   = logic_and (&quot;||&quot; logic_and)*
logic_and  = equality (&quot;&amp;&amp;&quot; relational)*
equality   = relational (&quot;==&quot; relational | &quot;!=&quot; relational)*
add        = mul (&quot;+&quot; mul | &quot;-&quot; mul)*
mul        = unary (&quot;*&quot; unary | &quot;/&quot; unary)*
unary      = (&quot;+&quot; | &quot;-&quot;)? primary
primary    = num | &quot;(&quot; expr &quot;)&quot;
</code></pre>
<p>这种复杂性和Go语言推崇的少即是多的哲学是相悖的！其实Go语言在设计表达式时有意无意地忽略了对右结合二元表达式的支持，如果配合运算符的优先级可以实现更简单的二元表达式解析。</p>
<p>下面我们看看如何简化二元表达式解析。四则运算表达式简化的ENBNF语法如下：</p>
<pre><code class="language-bnf">expr  = unary (&quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot;) unary)*
unary = (&quot;+&quot; | &quot;-&quot;)? primary
</code></pre>
<p>不在区分优先级，只有二元和一元表达式之分。因为二元表达式只有左结合一种，配合运算符优先级可以控制剩余表达式左结合的时机。</p>
<p>下面重新实现ParseExpr函数：</p>
<pre><code class="language-go">func ParseExpr(input []Token) *ExprNode {
	r := NewTokenReader(input)
	return parseExpr(r)
}

func parseExpr(r *TokenReader) *ExprNode {
	return parseExpr_binary(r, 1)
}
</code></pre>
<p>内部将Token列表转换为TokenReader，然后调用内部parseExpr函数。parseExpr函数以优先级1为参数调用parseExpr_binary解析二元表达式。</p>
<p>parseExpr_binary实现如下：</p>
<pre><code class="language-go">func parseExpr_binary(r *TokenReader, prec int) *ExprNode {
	x := parseExpr_unary(r)
	for {
		op := r.PeekToken()
		if op.Type.Precedence() &lt; prec {
			return x
		}

		r.MustAcceptToken(op.Type)
		y := parseExpr_binary(r, op.Type.Precedence()+1)
		x = &amp;ExprNode{Token: op, Left: x, Right: y}
	}
	return nil
}
</code></pre>
<p>首先是parseExpr_unary产生一个一元的表达式，然后根据运算符op优先级和当前处理的优先级大小控制剩余表达式的递归时机。如果op比当前函数处理的优先级更高，则继续将下一个表达式递归左结合到x中，否则结束当前左结合。</p>
<p>一元表达式的解析如下：</p>
<pre><code class="language-go">func parseExpr_unary(r *TokenReader) *ExprNode {
	if _, ok := r.AcceptToken(ADD); ok {
		return parseExpr_primary(r)
	}
	if _, ok := r.AcceptToken(SUB); ok {
		return &amp;ExprNode{
			Token: Token{Type: SUB},
			Left:  &amp;ExprNode{Token: Token{Type: NUMBER, Val: &quot;0&quot;}},
			Right: parseExpr_primary(r),
		}
	}
	return parseExpr_primary(r)
}
</code></pre>
<p>如果是<code>+x</code>则用<code>x</code>表示，如果是<code>-x</code>则用<code>0-x</code>表示。parseExpr_primary 则表示一个数值或小括弧包含的表达式，实现如下：</p>
<pre><code class="language-go">func parseExpr_primary(r *TokenReader) *ExprNode {
	if _, ok := r.AcceptToken(LPAREN); ok {
		expr := parseExpr(r)
		r.MustAcceptToken(RPAREN)
		return expr
	}
	return &amp;ExprNode{
		Token: r.MustAcceptToken(NUMBER),
	}
}
</code></pre>
<p>现在我们得到了一个更加简洁的支持多优先级只有左结合二元表达式的解析器。以后如果要支持相等更多的优先级运算符，则需要更新Token类型的优先级即可，解析器部分的代码不用变化。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="3-最小µgo程序"><a class="header" href="#3-最小µgo程序">3. 最小µGo程序</a></h1>
<p>本章将尝试编译最小的最小µGo程序，代码如下：</p>
<pre><code class="language-go">package main

func main() {
	exit(40+2) // 退出码 42
}
</code></pre>
<p>针对最小µGo程序，我们需要重新设计完善AST，然后编译main函数的唯一一个函数调用语句。exit则是作为builtin函数，完成退出程序的操作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="31-ast视角的µgo程序"><a class="header" href="#31-ast视角的µgo程序">3.1 AST视角的µGo程序</a></h1>
<p>最小的µGo程序虽然只有一个函数，函数中只有一个exit函数调用，但是已经是具有一个完整的程序的基本结构。本节我们将从AST角度分析最小µGo程序的结构，AST相关的代码在ast子包定义。</p>
<h2 id="311-最小µgo程序"><a class="header" href="#311-最小µgo程序">3.1.1 最小µGo程序</a></h2>
<p>最小µGo程序代码如下：</p>
<pre><code class="language-go">package main

func main() {
	exit(40+2) // 退出码 42
}
</code></pre>
<h2 id="312-package信息"><a class="header" href="#312-package信息">3.1.2 Package信息</a></h2>
<p>为了减少干扰，我们先排除全部的注释信息。有含义的语句首先是<code>package main</code>，表示这是一个main包。我们可以定义一个<code>Package</code>结构表示：</p>
<pre><code class="language-go">type Package struct {
	PkgPos  int
	NamePos int
	Name    string
}
</code></pre>
<p>其中PkgPos表示package关键字的位置，NamePos表示包名的开始位置，Name表示包的名字。我们通过在Package结构定义关键元素的值和位置信息，就可以精确表示文本格式的µGo程序（或则说可以轻松将<code>ast.Package</code>这个结构原样恢复出原始的µGo程序，而代码和AST的双向转换正是语法解析和代码格式化的基础）。</p>
<h2 id="313-函数定义"><a class="header" href="#313-函数定义">3.1.3 函数定义</a></h2>
<p>然后是函数的表示：这个最小程序虽然只有一个main函数，但是正常的µGo程序可以定义很多个函数。。我们现在尝试定义一个可以表示函数AST的Func结构：</p>
<pre><code class="language-go">type Func struct {
	FuncPos int
	NamePos int
	Name    string
	Body    *BlockStmt
}
</code></pre>
<p>其中FuncPos和NamePos分别是func关键字和函数名字的开始位置，Name表示函数的名字（同样为了简单，我们忽略函数的参数和返回值信息，也忽略了小括弧的位置信息），然后BlockStmt类型的Body表示函数体内的语句。</p>
<h2 id="314-块语句"><a class="header" href="#314-块语句">3.1.4 块语句</a></h2>
<p>目前函数虽然只有一个<code>exit(40+2)</code>语句，但是真实的µGo程序同样可以包含多个不同类型的语句。语句大约可以看作是分号分隔的、相同层级、顺序执行的代码。上面代码出现的BlockStmt就表示一个块语句，一个块语句是大括弧包含的语句序列。BlockStmt定义如下：</p>
<pre><code class="language-go">type BlockStmt struct {
	Lbrace int // '{'
	List   []Stmt
	Rbrace int // '}'
}
</code></pre>
<p>其中Lbrace和Rbrace是左右大括弧的位置，而List则是Stmt接口表示的语句列表。因为µGo程序中可能有变量定义、赋值、表达式、if、for、return等不同类型的语句，因此我们需要定义一个Stmt类型的接口来表示语句：</p>
<pre><code class="language-go">type Stmt interface {
	Pos() int
	End() int
	stmt_type()
}
</code></pre>
<p>语句也有一些共性的方法，其中Pos和End返回语句的开始和结束位置，对应一个语句代码的区间。同时为了区分Stmt和其他类型，我们定义了一个stmt_type私有方法。</p>
<h2 id="315-表达式语句"><a class="header" href="#315-表达式语句">3.1.5 表达式语句</a></h2>
<p>光有Stmt接口我们依然无法表示目前的最小µGo程序。我们还需要为表达式语句定义一个ExprStmt结构：</p>
<pre><code class="language-go">type ExprStmt struct {
	X Expr
}

type Expr interface {
	Pos() int
	End() int
	expr_type()
}
</code></pre>
<p>ExprStmt结构中只有一个X成员，表示一个Expr类型的表达式（表达式可以产生值，也可能没有值，比如一个没有返回值的函数调用）。而Expr是与Stmt类似的接口，用于表示具体的表达式的构成。</p>
<h2 id="316-四则运算表达式结构"><a class="header" href="#316-四则运算表达式结构">3.1.6 四则运算表达式结构</a></h2>
<p>在表达式一章我们已经通过一个简化的ExprNode节点表示全部的一元和二元表达式。但是目前的最小µGo程序出现了新的表达式结构：函数调用。因此，我们需要为表达式定义更为友好的结构：</p>
<pre><code class="language-go">type Number struct {
	ValuePos int
	ValueEnd int
	Value    int
}

type BinaryExpr struct {
	Op token.Token // 运算符
	X  Expr        // 左边的运算对象
	Y  Expr        // 右边的运算对象
}

type UnaryExpr struct {
	Op    token.Token // 运算符
	X     Expr        // 运算对象
}

type ParenExpr struct {
	Lparen int  // &quot;(&quot; 的位置
	X      Expr // 圆括弧内的表达式对象
	Rparen int  // &quot;)&quot; 的位置
}
</code></pre>
<p>其中Number表示一个普通的整数字面值、BinaryExpr表示二元表达式、UnaryExpr表示一元表达式、ParenExpr表示小括弧表达式。其中递归的表达式定义都是Expr类型，其他属性则是运算符类型和位置信息等。需要注意到是token.Token是一个词法记号值，其中不仅仅包含记号的类型和字面值，还包含记号的位置信息（在稍后的词法分析部分会继续讨论）。</p>
<h2 id="317-函数调用表达式"><a class="header" href="#317-函数调用表达式">3.1.7 函数调用表达式</a></h2>
<p>函数调用表达式定义如下：</p>
<pre><code class="language-go">type CallExpr struct {
	FuncPos  int
	FuncName string
	Lparen   int
	Args     []Expr
	Rparen   int
}
</code></pre>
<p>FuncPos和FuncName是调用函数的名字和位置信息，Lparen和Rparen是小括弧位置，Args则是函数的参数表达式列表。</p>
<h2 id="318-file结构"><a class="header" href="#318-file结构">3.1.8 File结构</a></h2>
<p>最小µGo程序的全部元素以已经定义，我们现在定义一个File结构表示一个文件：</p>
<pre><code class="language-go">type File struct {
	Pkg   *Package
	Funcs []Func
}
</code></pre>
<p>其中Pkg表示包信息，Funcs则表示文件中顺序出现的函数列表。</p>
<h2 id="319-ast表示的µgo程序"><a class="header" href="#319-ast表示的µgo程序">3.1.9 AST表示的µGo程序</a></h2>
<p>现在我们尝试通过AST表示µGo程序（为了方便表示，我们暂时忽略位置信息）：</p>
<pre><code class="language-go">import &quot;github.com/chai2010/ugo/ast&quot;
import &quot;github.com/chai2010/ugo/token&quot;

var ugoProg = &amp;ast.File {
	Pkg: &amp;ast.Package{
		Name: &quot;main&quot;,
	},
	Funcs: []ast.Func{
		{
			Name: &quot;main&quot;,
			Body: &amp;ast.BlockStmt {
				List: []ast.Stmt{
					&amp;ast.ExprStmt{
						X: &amp;ast.CallExpr{
							FuncName: &quot;exit&quot;,
							Args: []ast.Expr{
								&amp;ast.BinaryExpr{
									Op: token.Token{Type: token.ADD},
									X:  &amp;ast.Number{Value: 40},
									Y:  &amp;ast.Number{Value: 2},
								},
							},
						},
					},
				},
			},
		},
	},
}
</code></pre>
<p>这样我们就得到了一个全新形式表示的µGo程序。</p>
<h2 id="3110-小结"><a class="header" href="#3110-小结">3.1.10 小结</a></h2>
<p>AST是编译器前后端链接的纽带：AST虽然看起来繁琐，但是结构非常清晰，非常适合程序处理。有了AST之后我们不仅仅可以进行语义检查、编译到汇编代码、也可以进行AST结构转换和代码格式化等很多工作。在本章稍后，我们将围绕AST明确token包的结构、讨论如何遍历AST、以及如何从AST输出LLVM汇编代码。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="32-ast到llvm汇编"><a class="header" href="#32-ast到llvm汇编">3.2 AST到LLVM汇编</a></h1>
<p>在前一节我们已经采用AST形式编写了一个最小µGo程序，本节我们尝试将这个AST翻译到LLVM汇编程序。</p>
<h2 id="321-对应的llvm汇编程序"><a class="header" href="#321-对应的llvm汇编程序">3.2.1 对应的LLVM汇编程序</a></h2>
<p>我们已经了解了AST的数据结构，在翻以前我们还需要明确要输出的汇编代码的形式。只有先在大脑人肉完成翻译工作后，才真正好通过程序实现自动化的翻译。</p>
<p>结合第二章表达式的内容，可以想象输出以下的汇编程序：</p>
<pre><code class="language-ll">declare i32 @ugo_builtin_exit(i32)

define i32 @ugo_main_main() {
	%t0 = add i32 0, 40    ; t0 = 40
	%t1 = add i32 0, 2     ; t1 = 2
	%t2 = add i32 %t0, %t1 ; t2 = t1 + t1
	call i32(i32) @ugo_builtin_exit(i32 %t2)
	ret i32 0
}
</code></pre>
<p>第一句是通过declare声明<code>@ugo_builtin_exit</code>内置函数（稍后通过其他工具生成），其作用是将一个整数参数作为退出码退出程序。然后<code>@ugo_main_main</code>是µGo的main包中的main函数输出的LLVM对应的函数，并在开头增加了<code>ugo_</code>前缀。函数体则是通过计算一个表达式，然后作为参数调用µGo的exit内置函数对应的代码。</p>
<p>要执行该程序需要在main入口函数调用<code>@ugo_main_main</code>函数：</p>
<pre><code class="language-ll">define i32 @main() {
	call i32() @ugo_main_main()
	ret i32 0
}
</code></pre>
<p>以上这2段代码就是我们的编译器需要生成的汇编程序。</p>
<h2 id="322-准备ugobuiltinexit内置函数"><a class="header" href="#322-准备ugobuiltinexit内置函数">3.2.2 准备<code>@ugo.builtin.exit</code>内置函数</a></h2>
<p>为了简单，我们采用C语言实现µGo内置的<code>@ugo_builtin_exit</code>函数：</p>
<pre><code class="language-c">// builtin.c
extern int exit(int);

int ugo_builtin_exit(int x) {
	exit(x);
	return 0;
}
</code></pre>
<p>然后用<code>clang -S -emit-llvm builtin.c</code>将C代码转化为LLVM汇编语言格式。输出的<code>builtin.ll</code>文件如下：</p>
<pre><code class="language-ll">declare void @exit(i32)

define i32 @ugo_builtin_exit(i32) {
  %2 = alloca i32, align 4
  store i32 %0, i32* %2, align 4
  %3 = load i32, i32* %2, align 4
  %4 = call i32 @exit(i32 %3)
  unreachable
}
</code></pre>
<p>然后结合前面编译器将要生成的<code>main.ll</code>程序，用clang命令再编译连接执行：</p>
<pre><code>$ clang builtin.ll main.ll
$ ./a.out
$ echo $?
42
</code></pre>
<p>验证一切正常之后，我们就可以开始尝试用程序生成<code>main.ll</code>了。</p>
<h2 id="323-构造compilercompiler对象"><a class="header" href="#323-构造compilercompiler对象">3.2.3 构造<code>compiler.Compiler</code>对象</a></h2>
<p>编译器的代码放在compiler包，其中Compiler对象提供一个编译方法：</p>
<pre><code class="language-go">type Compiler struct{}

func (p *Compiler) Compile(f *ast.File) string {
	var buf bytes.Buffer

	p.genHeader(&amp;buf, file)
	p.compileFile(&amp;buf, file)
	p.genMain(&amp;buf, file)

	return buf.String()
}
</code></pre>
<p>参数是输入的<code>ast.File</code>，对应µGo程序的AST。其中<code>p.genHeader</code>调用用于生成内置函数的声明，<code>p.compileFile</code>则将µGo程序编译为LLVM汇编，最后<code>p.genMain</code>将<code>main.main</code>函数挂到入口的main函数。</p>
<h2 id="324-内置函数声明和入口代码生成"><a class="header" href="#324-内置函数声明和入口代码生成">3.2.4 内置函数声明和入口代码生成</a></h2>
<p>内置函数的声明和入口函数的定义均在builtin包定义：</p>
<pre><code class="language-go">package builtin

const Header = `
declare i32 @ugo_builtin_exit(i32)
`

const MainMain = `
define i32 @main() {
	call i32() @ugo_main_main()
	ret i32 0
}
`
</code></pre>
<p>对应的编译函数实现：</p>
<pre><code class="language-go">package compiler

import (
	&quot;github.com/chai2010/ugo/builtin&quot;
)

func (p *Compiler) genHeader(w io.Writer, file *ast.File) {
	fmt.Fprintf(w, &quot;; package %s\n&quot;, file.Pkg.Name)
	fmt.Fprintln(w, builtin.Header)
}

func (p *Compiler) genMain(w io.Writer, file *ast.File) {
	if file.Pkg.Name != &quot;main&quot; {
		return
	}
	for _, fn := range file.Funcs {
		if fn.Name == &quot;main&quot; {
			fmt.Fprintln(w, builtin.MainMain)
			return
		}
	}
}
</code></pre>
<p>genHeader方法首先生成注释说明当前边缘的源文件信息，然后输出内置函数的声明。genMain函数则是针对<code>main.main</code>输出main入口函数。</p>
<h2 id="325-编译文件"><a class="header" href="#325-编译文件">3.2.5 编译文件</a></h2>
<p>因为目前的程序比较简单，AST中只有函数。compileFile实现如下：</p>
<pre><code class="language-go">func (p *Compiler) compileFile(w io.Writer, file *ast.File) {
	for _, fn := range file.Funcs {
		p.compileFunc(w, file, fn)
	}
}
</code></pre>
<p>只是简单遍历<code>file.Funcs</code>包含的每个函数，然后调用p.compileFunc编译函数。</p>
<p>p.compileFunc实现如下：</p>
<pre><code class="language-go">func (p *Compiler) compileFunc(w io.Writer, file *ast.File, fn *ast.Func) {
	if fn.Body == nil {
		fmt.Fprintf(w, &quot;declare i32 @ugo_%s_%s() {\n&quot;, file.Pkg.Name, fn.Name)
		return
	}

	fmt.Fprintf(w, &quot;define i32 @ugo_%s_%s() {\n&quot;, file.Pkg.Name, fn.Name)
	p.compileStmt(w, fn.Body)

	fmt.Fprintln(w, &quot;\tret i32 0&quot;)
	fmt.Fprintln(w, &quot;}&quot;)
}
</code></pre>
<p>如果函数没有Body，则产生函数的声明，否则则输出完整的函数定义。函数的定义对应一个块语句，通过p.compileStmt函数完成编译。输出的函数名字做了简单的名字修饰——增加了当前包的名字。</p>
<h2 id="326-编译语句"><a class="header" href="#326-编译语句">3.2.6 编译语句</a></h2>
<p>语句是编程语言中最有价值的部分，比如if、for这些都是语句。目前的程序只有块和表达式两种语句，compileStmt实现如下：</p>
<pre><code class="language-go">func (p *Compiler) compileStmt(w io.Writer, stmt ast.Stmt) {
	switch stmt := stmt.(type) {
	case *ast.BlockStmt:
		for _, x := range stmt.List {
			p.compileStmt(w, x)
		}
	case *ast.ExprStmt:
		p.compileExpr(w, stmt.X)

	default:
		panic(&quot;unreachable&quot;)
	}
}
</code></pre>
<p>其实函数的Body就是一个<code>*ast.BlockStmt</code>，只要针对其中的每个语句再次递归调用<code>p.compileStmt</code>编译即可。如果是普通的表达式语句，则调用<code>p.compileExpr</code>编译表达式。</p>
<h2 id="327-编译表达式"><a class="header" href="#327-编译表达式">3.2.7 编译表达式</a></h2>
<p>我们已经在第二章展示过如何编译加减乘除构成的表达式，现在的表达式则增加了一个函数调用，但是实现的方式依然相似。</p>
<p>调套表达式的特点是每个节点最多产生一个值（不返回或返回多个值的一般不会出现在前套的表达式中，只需要特化处理即可），只需要针对每个表达式节点类型分别处理：</p>
<pre><code class="language-go">func (p *Compiler) compileExpr(w io.Writer, expr ast.Expr) (localName string) {
	switch expr := expr.(type) {
	case *ast.Number:
		// %t1 = add i32 0, x; x
		return `%t1`
	case *ast.BinaryExpr:
		// %t1 = bin_op i32 x, y; x+y
		return `%t1`
	case *ast.UnaryExpr:
		// %t1 = sub i32 0, x; -x, or x
		return `%t1`
	case *ast.ParenExpr:
		// %t1 = %t0; (x) -&gt; x
		return `%t1`
	case *ast.CallExpr:
		// %t1 = call i32(i32) func(i32 %x)
		return `%t1`
	}
	panic(&quot;unreachable&quot;)
}
</code></pre>
<p>普通的数字面值、二元、一元和小括弧和第2章产生的方式类似：</p>
<pre><code class="language-go">func (p *Compiler) compileExpr(w io.Writer, expr ast.Expr) (localName string) {
	switch expr := expr.(type) {
	case *ast.Number:
		localName = p.genId()
		fmt.Fprintf(w, &quot;\t%s = %s i32 %v, %v\n&quot;,
			localName, &quot;add&quot;, `0`, expr.Value,
		)
		return localName
	case *ast.BinaryExpr:
		localName = p.genId()
		switch expr.Op.Type {
		case token.ADD:
			fmt.Fprintf(w, &quot;\t%s = %s i32 %v, %v\n&quot;,
				localName, &quot;add&quot;, p.compileExpr(w, expr.X), p.compileExpr(w, expr.Y),
			)
			return localName
		case token.SUB:
			// ...
		case token.MUL:
			// ...
		case token.DIV:
			// ...
		}
	case *ast.UnaryExpr:
		if expr.Op.Type == token.SUB {
			localName = p.genId()
			fmt.Fprintf(w, &quot;\t%s = %s i32 %v, %v\n&quot;,
				localName, &quot;sub&quot;, `0`, p.compileExpr(w, expr.X),
			)
			return localName
		}
		return p.compileExpr(w, expr.X)
	case *ast.ParenExpr:
		return p.compileExpr(w, expr.X)

	// ...
</code></pre>
<p>函数调用是新加的，实现如下：</p>
<pre><code class="language-go">	case *ast.CallExpr:
		// call i32(i32) @ugo_builtin_exit(i32 %t2)
		localName = p.genId()
		fmt.Fprintf(w, &quot;\t%s = call i32(i32) @ugo_builtin_%s(i32 %v)\n&quot;,
			localName, expr.FuncName, p.compileExpr(w, expr.Args[0]),
		)
		return localName
	}

	panic(&quot;unreachable&quot;)
}
</code></pre>
<p>为了简化函数的返回值和参数类型目前是固定的，函数的名字增加一个<code>@ugo_builtin_</code>前缀。到此我们基本完成了编译器后端的基础工作。</p>
<h2 id="328-组装编译器"><a class="header" href="#328-组装编译器">3.2.8 组装编译器</a></h2>
<p>现在我们可以构造一个测试程序，将AST和编译函数串起来：</p>
<pre><code class="language-go">package main

import (
	&quot;fmt&quot;

	&quot;github.com/chai2010/ugo/ast&quot;
	&quot;github.com/chai2010/ugo/compiler&quot;
)

func main() {
	ast := &amp;ast.File{} // 用ch3.1内容填充
	ll := new(compiler.Compiler).Compile(ast)
	fmt.Print(ll)
}
</code></pre>
<p>输出的LL汇编程序：</p>
<pre><code class="language-ll">; package main

declare i32 @ugo_builtin_exit(i32)

define i32 @ugo_main_main() {
	%t2 = add i32 0, 40
	%t3 = add i32 0, 2
	%t1 = add i32 %t2, %t3
	%t0 = call i32(i32) @ugo_builtin_exit(i32 %t1)
	ret i32 0
}

define i32 @main() {
	call i32() @ugo_main_main()
	ret i32 0
}
</code></pre>
<p>这样我们就实现了自动翻译的编译器程序。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="33-完善词法解析器"><a class="header" href="#33-完善词法解析器">3.3 完善词法解析器</a></h1>
<p>以最小µGo程序为例，本节讨论如何继续完善词法解析器，为后续的语法解析器提供基础。</p>
<h2 id="331-token视角的µgo程序"><a class="header" href="#331-token视角的µgo程序">3.3.1 Token视角的µGo程序</a></h2>
<p>英语和中文有着极大的区别：英语由少量的26个字母构成，然后由字母再构造成一个个单词，而这些单词和中文的一个个汉字类似，每个单词都有着一定的语义。词法分析的工作和英语中从字母序列分析为单词序列的工作类似（中文应为汉字数量众多，词法解析的比重相对较低）。我们看到的程序其实都是字母序列，因此第一步工作是将字母序列转换为单词序列。</p>
<p>而µGo编译器中每个单词对应属于Token，一个Token可以是一个数字、也可以是一个变量名，或则是一个加法符号。我们现在以Token视角看看之前的µGo程序是什么样子的。</p>
<p>最小µGo程序的字母序列（为了不被语法高亮的特性迷惑，这里刻意关闭了语法高亮特性）：</p>
<pre><code class="language-txt">package main

func main() {
	exit(40+2) // 退出码 42
}
</code></pre>
<p>对应的Token序列如下（忽略注释部分）：</p>
<pre><code class="language-go">import &quot;github.com/chai2010/ugo/token&quot;

var ugoTokens = []token.Token {
	{Type: token.PACKAGE},              // package
	{Type: token.IDENT, Value: &quot;main&quot;}, // main
	{Type: token.FUNC},                 // func
	{Type: token.IDENT, Value: &quot;main&quot;}, // main
	{Type: token.LPAREN},               // (
	{Type: token.RPAREN},               // )
	{Type: token.LBRACE},               // {
	{Type: token.IDENT, Value: &quot;exit&quot;}, // exit
	{Type: token.LPAREN},               // (
	{Type: token.NUMBER, Value: 40},    // 40
	{Type: token.ADD},                  // +
	{Type: token.NUMBER, Value: 2},     // 2
	{Type: token.RPAREN},               // )
	{Type: token.RBRACE},               // }
}
</code></pre>
<p>这种转化也就是此法解析器需要完成的工作：我们需要在能够尽量准确表达原始程序的前提下尽量简化后续解析器的分析工作。目前看，这个词法序列似乎是可以准确表示最小µGo程序的。</p>
<h2 id="332-分号和注释"><a class="header" href="#332-分号和注释">3.3.2 分号和注释</a></h2>
<p>我们尝试再从Token序列反向恢复出原始的µGo程序：</p>
<pre><code class="language-go">package main func main() { exit(40+2) }
</code></pre>
<p>实际上这是个错误的Go程序，将会产生以下的语法错误：</p>
<pre><code>syntax error: unexpected func, expecting semicolon or newline
</code></pre>
<p>简单说，在<code>package main</code>和<code>func</code>之间至少要有一个换行符号或则是分号。其实语法解析器最终需要的是分号，因为分号才是Go语言中语句的分隔符号（正如空白也是单词之间的分隔符）。而Go语言的词法解析起在解析时如果是特殊的Token遇到换行（标识符、数字或字符串等字面值、break/continue/fallthrough/return等关键字、<code>++</code>/<code>--</code>/<code>)</code>/<code>]</code>/<code>}</code>等运算符，同时<code>)</code>/<code>}</code>之前的分号可以省略，具体请参考 <a href="https://golang.google.cn/ref/spec#Semicolons">spec</a> 文档），会自动添加分号。</p>
<p>同样，注释是可以以任意的形式混入在Token序列之间的。如果加入注释的干扰，会导致语法的定义和分析变得复杂。常见的做法是词法解析的同时记录每个Token的位置信息，词法解析完成后将注释剥离再进行语法解析，等语法解析器完成AST构造之后再将注释根据位置合并到AST的相应结点中。</p>
<h2 id="333-完善token包的记号类型"><a class="header" href="#333-完善token包的记号类型">3.3.3 完善token包的记号类型</a></h2>
<p>token包的内容和第2章结构类似，增加了部分新的关键字类型：</p>
<pre><code class="language-go">package token

// 记号类型
type TokenType int

// ch3中 µGo程序用到的记号类型
const (
	EOF TokenType = iota
	ERROR
	COMMENT

	IDENT
	NUMBER

	PACKAGE
	FUNC

	ADD // +
	SUB // -
	MUL // *
	DIV // /

	LPAREN // (
	RPAREN // )
	LBRACE // {
	RBRACE // }

	SEMICOLON // ;
)
</code></pre>
<p>增加了IDENT表示标识符、PACKAGE定义包、FUNC针对函数大括弧用于定义函数的Body、并引入了分号。如果是语法位置记号用ERROR表示，EOF表示文件结束。同时增加了COMMENT表示注释。</p>
<p>token.Token对应记号的值（含记号类型、解析后的值、位置和原始面值）：</p>
<pre><code class="language-go">type Token struct {
	Type    TokenType   // 记号的类型
	Value   interface{} // 记号的值, 目前只有 int
	Pos     int         // 记号所在的位置(从1开始)
	Literal string      // 程序中原始的字符串
}
</code></pre>
<p>这样我们就可以用<code>[]token.Token</code>表示的记号序列来等价地表示词法解析后的代码。</p>
<h3 id="334-重构词法解析器"><a class="header" href="#334-重构词法解析器">3.3.4 重构词法解析器</a></h3>
<p>在地2章最后的例子中，我们通过包装<code>text/scanner</code>标准库实现了词法解析。这种方式虽然可以用于µGo程序，但是依然有隔山打牛的弊端。本节我们该用纯手工的方式重新实现词法解析，这样不仅仅可以让我们可以了解词法解析的实现细节，而且词法解析的套路依然可以用于后续的AST解析工作。这种问题只要彻底解决一次就一劳永逸了。</p>
<h4 id="3341-源文件sourcestream"><a class="header" href="#3341-源文件sourcestream">3.3.4.1 源文件SourceStream</a></h4>
<p>词法解析的输入是字节流，在解析的过程中常常需要向前多看一个字符，同时也可能要忽略一些字符，为此我们需要先构造一个字节流的SourceStream对象（这个设计同样可以复制到Token流，用于语法解析）。</p>
<p>SourceStream定义的API如下：</p>
<pre><code class="language-go">type SourceStream struct {}

func NewSourceStream(name, src string) *SourceStream

func (p *SourceStream) Name() string
func (p *SourceStream) Input() string

func (p *SourceStream) Pos() int
func (p *SourceStream) Peek() rune
func (p *SourceStream) Read() rune
func (p *SourceStream) Unread()

func (p *SourceStream) Accept(valid string) bool
func (p *SourceStream) AcceptRun(valid string) (ok bool)

func (p *SourceStream) EmitToken() (lit string, pos int)
func (p *SourceStream) IgnoreToken()
</code></pre>
<p>NewSourceStream根据文件名和内容构造一个SourceStream对象。其Name和Input方法分别返回源文件的名字和内容。Pos方法返回当前读的位置，Peek预取下一个字符、Read读取下一个字符、Unread用于一次回退。Accept会尝试消费一个存在于valid中的字符，而AcceptRun则会尝试尽量消费多个存在于valid中的字符。EmitToken方法用于产生当前读取到的记号面值和位置信息，IgnoreToken则忽略当前的记号。</p>
<p>SourceStream中最基础的核心函数Read和Unread实现如下：</p>
<pre><code class="language-go">type SourceStream struct {
	name  string // 文件名
	input string // 输入的源代码
	start int    // 当前正解析中的记号的开始位置
	pos   int    // 当前读取的位置
	width int    // 最后一次读取utf8字符的字节宽度, 用于回退
}

func (p *SourceStream) Read() rune {
	if p.pos &gt;= len(p.input) {
		p.width = 0
		return 0
	}

	r, size := utf8.DecodeRune([]byte(p.input[p.pos:]))
	p.width = size
	p.pos += p.width
	return r
}
func (p *SourceStream) Unread() {
	p.pos -= p.width
	return
}
</code></pre>
<p>Read方法会解码并读一个utf8字符，其中<code>p.width</code>用于记录当前读取字符的utf8编码的字节宽度，如果遇到结尾则返回0。Unread方法则可以用于进行一次回退刚刚读取的Read操作（不能进行多次回退）。</p>
<p>基于Read和Unread可以很容易实现Peek、Accept和AcceptRun等方法：</p>
<pre><code class="language-go">func (p *SourceStream) Peek() rune {
	x := p.Read()
	p.Unread()
	return x
}
func (p *SourceStream) Accept(valid string) bool {
	if strings.IndexRune(valid, rune(p.Read())) &gt;= 0 {
		return true
	}
	return false
}

func (p *SourceStream) AcceptRun(valid string) (ok bool) {
	for p.Accept(valid) {
		ok = true
	}
	p.Unread()
	return
}
</code></pre>
<p>Peek等方法先用Read进行正常读取，如果失败则调用Unread回退最近一次的Read操作。</p>
<p>最后是产生记号面值的实现：</p>
<pre><code class="language-go">func (p *SourceStream) EmitToken() (lit string, pos int) {
	lit, pos = p.input[p.start:p.pos], p.start
	p.start = p.pos
	return
}

func (p *SourceStream) IgnoreToken() {
	_, _ = p.EmitToken()
}
</code></pre>
<p>EmitToken返回的记号面值和位置是构造token.Token的必要数据。</p>
<h4 id="3342-基于sourcestream重构词法解析器"><a class="header" href="#3342-基于sourcestream重构词法解析器">3.3.4.2 基于SourceStream重构词法解析器</a></h4>
<p>词法解析器的API定义如下：</p>
<pre><code class="language-go">type Lexer struct {}

func NewLexer(name, input string) *Lexer
func (p *Lexer) Comments() []token.Token
func (p *Lexer) Tokens() []token.Token
</code></pre>
<p>NewLexer基于源文件名和内容构造解析器，Comments方法返回注释列表，Tokens方法返回非注释列表。</p>
<p>Lexer基于SourceStream对象构建：</p>
<pre><code class="language-go">type Lexer struct {
	*SourceStream
	tokens   []token.Token
	comments []token.Token
}

func NewLexer(name, input string) *Lexer {
	p := &amp;Lexer{ SourceStream: NewSourceStream(name, input)}
	p.run()
	return p
}

func (p *Lexer) Tokens() []token.Token {
	return p.tokens
}

func (p *Lexer) Comments() []token.Token {
	return p.comments
}
</code></pre>
<p>NewLexer在构造Lexer对象后，调用私有的<code>p.run</code>函数将源代码解析为词法列表。</p>
<p>在实现词法解析之前先定义一个emit方法用于产生记号，实现如下：</p>
<pre><code class="language-go">func (p *Lexer) emit(typ token.TokenType) {
	lit, pos := p.EmitToken()
	if typ == token.IDENT {
		typ = token.Lookup(lit)
	}
	p.tokens = append(p.tokens, token.Token{
		Type:    typ,
		Literal: lit,
		Pos:     pos,
	})
}
</code></pre>
<p>手写通过<code>p.EmitToken()</code>调用内部SourceStream对象提供的方法，然后构造新的token.Token对象并添加到p.tokens列表。如果是标识符类型，则通过token.Lookup(lit)查询是否为关键字类型。</p>
<p>我们还需要一个产生注释记号的emitComment方法：</p>
<pre><code class="language-go">func (p *Lexer) emitComment() {
	lit, pos := p.EmitToken()
	p.comments = append(p.comments, token.Token{
		Type:    token.COMMENT,
		Literal: lit,
		Pos:     pos,
	})
}
</code></pre>
<p>注释也是一种token.Token，只是记录到了另一个p.comments成员中。将注释分开的原因是为了屏蔽注释对正常词法流的干扰，例如在遇到换行需要决策是否添加分号时注释会带来噪声。</p>
<p>我们还需要一个错误处理函数记录不能识别的记号：</p>
<pre><code class="language-go">func (p *Lexer) errorf(format string, args ...interface{}) {
	tok := token.Token{
		Type:    token.ERROR,
		Literal: fmt.Sprintf(format, args...),
		Pos:     p.Pos(),
	}
	p.tokens = append(p.tokens, tok)
	panic(tok)
}
</code></pre>
<p>错误也是一种特殊的记号，添加到p.tokens成员，然后调用panic抛出异常快速退出到外层函数。</p>
<p>最后也是最重要的run方法解析记号：</p>
<pre><code class="language-go">func (p *Lexer) run() (tokens []token.Token) {
	defer func() {
		tokens = p.tokens
		if r := recover(); r != nil {
			if _, ok := r.(token.Token); !ok {
				panic(r)
			}
		}
	}()
	...
</code></pre>
<p>首先是在defer函数中捕获errorf方法抛出的异常。词法解析的具体工作在一个for循环进行：</p>
<pre><code class="language-go">	for {
		r := p.Read()
		if r == rune(token.EOF) {
			p.emit(token.EOF)
			return
		}

		switch {
		case r == '\n':
		case isSpace(r):
		...
		}
	}
}
</code></pre>
<p>每次循环开始读取一个字符，判断如果是结束则产生EOF类型的记号并退出。否则通过switch多分枝分别解析不同类型的记号。</p>
<p>比如遇到换行时解析方式如下：</p>
<pre><code class="language-go">		case r == '\n':
			p.IgnoreToken()
			if len(p.tokens) &gt; 0 {
				switch p.tokens[len(p.tokens)-1].Type {
				case token.RPAREN, token.IDENT, token.NUMBER:
					p.emit(token.SEMICOLON)
				}
			}
</code></pre>
<p>首先是通过p.IgnoreToken()忽略换行前读取的内容。然后判断是否已经读取到过记号，如果是并且前一个读取的记号是右小括弧、数字或标识符等类型时插入一个分号记号（类似Go语言可以省略大部分的行尾分号特性）。</p>
<p>如果是空白字符，则直接忽略：</p>
<pre><code class="language-go">		case isSpace(r):
			p.IgnoreToken()
</code></pre>
<p>如果是英文字母则尝试解析为标识符或关键字：</p>
<pre><code class="language-go">		case isAlpha(r):
			p.Unread()
			for {
				if r := p.Read(); !isAlphaNumeric(r) {
					p.Unread()
					p.emit(token.IDENT)
					break
				}
			}
</code></pre>
<p>数字的解析如下：</p>
<pre><code class="language-go">		case ('0' &lt;= r &amp;&amp; r &lt;= '9'): // 123, 1.0
			p.Unread()

			digits := &quot;0123456789&quot;
			p.AcceptRun(digits)
			p.emit(token.NUMBER)
</code></pre>
<p>如果是数字开头，则通过p.AcceptRun尽量读取多个数字字符，然后通过p.emit(token.NUMBER)产生数字记号。</p>
<p>四则运算符处理如下：</p>
<pre><code class="language-go">		case r == '+': // +, +=, ++
			p.emit(token.ADD)
		case r == '-': // -, -=, --
			p.emit(token.SUB)
		case r == '*': // *, *=
			p.emit(token.MUL)
		case r == '/': // /, //, /*, /=
			if p.Peek() != '/' {
				p.emit(token.DIV)
			}
</code></pre>
<p>加、减、乘目前都是单个字符，直接产生记号即可。除法要特殊一点，需要分别处理行注释的问题（多行注释暂不支持）：</p>
<pre><code class="language-go">		case r == '/': // /, //, /*, /=
			if p.Peek() != '/' {
				p.emit(token.DIV)
			} else {
				// line comment
				for {
					t := p.Read()
					if t == '\n' {
						p.Unread()
						p.emitComment()
						break
					}
					if t == rune(token.EOF) {
						p.emitComment()
						return
					}
				}
			}
</code></pre>
<p>如果是行注释直接读取到换行或文件末尾，需要注意的是在行注释结尾要判断是否要产生分号。</p>
<p>其他的特色记号如下：</p>
<pre><code class="language-go">		case r == '(':
			p.emit(token.LPAREN)
		case r == '{':
			p.emit(token.LBRACE)

		case r == ')':
			p.emit(token.RPAREN)
		case r == '}':
			p.emit(token.RBRACE)

		case r == ';':
			p.emit(token.SEMICOLON)
</code></pre>
<p>未知的记号直接抛出错误：</p>
<pre><code class="language-go">		default:
			p.errorf(&quot;unrecognized character: %#U&quot;, r)
			return
		}
</code></pre>
<p>run方法是词法解析的核心方法，虽然目前的处理相对粗糙，后续可以根据语法的提炼慢慢改进。</p>
<h4 id="335-格式化位置信息"><a class="header" href="#335-格式化位置信息">3.3.5 格式化位置信息</a></h4>
<p>在词法解析的过程中我们已经记录了每个记号的偏移量信息。如果结合文件名和内容可以转换为更适合阅读的行列号位置信息。</p>
<p>可以定义PosString函数用于将偏移量转位行列信息：</p>
<pre><code class="language-go">package lexer

import gotoken &quot;go/token&quot;

func PosString(filename string, src string, pos int) string {
	fset := gotoken.NewFileSet()
	fset.AddFile(filename, 1, len(src)).SetLinesForContent([]byte(src))
	return fmt.Sprintf(&quot;%v&quot;, fset.Position(gotoken.Pos(pos+1)))
}
</code></pre>
<p>为了简单，我们直接借助了Go语言自带的token.FileSet实现此功能。需要注意点时，pos是从0开始的，转行列表时pos需要加1.</p>
<h4 id="336-测试词法解析器"><a class="header" href="#336-测试词法解析器">3.3.6 测试词法解析器</a></h4>
<p>还是本章的最小µGo程序：</p>
<pre><code class="language-go">package main

func main() {
	exit(40 + 2) // exit code 42
}
</code></pre>
<p>词法解析程序如下：</p>
<pre><code class="language-go">import  &quot;github.com/chai2010/ugo/lexer&quot;

func main() {
	// 构造词法解析器
	code := loadCode(&quot;../hello.ugo&quot;)
	lexer := lexpkg.NewLexer(&quot;../hello.ugo&quot;, code)

	// 遍历正常记号
	for i, tok := range lexer.Tokens() {
		fmt.Printf(
			&quot;%02d: %-12v: %-20q // %s\n&quot;,
			i, tok.Type, tok.Literal,
			lexpkg.PosString(&quot;../hello.ugo&quot;, code, tok.Pos),
		)
	}

	fmt.Println(&quot;----&quot;)

	// 遍历注释
	for i, tok := range lexer.Comments() {
		fmt.Printf(
			&quot;%02d: %-12v: %-20q // %s\n&quot;,
			i, tok.Type, tok.Literal,
			lexpkg.PosString(&quot;../hello.ugo&quot;, code, tok.Pos),
		)
	}
}
</code></pre>
<p>输出的结果如下：</p>
<pre><code>00: PACKAGE     : &quot;package&quot;            // ../hello.ugo:1:1
01: IDENT       : &quot;main&quot;               // ../hello.ugo:1:9
02: SEMICOLON   : &quot;&quot;                   // ../hello.ugo:2:1
03: FUNC        : &quot;func&quot;               // ../hello.ugo:3:1
04: IDENT       : &quot;main&quot;               // ../hello.ugo:3:6
05: LPAREN      : &quot;(&quot;                  // ../hello.ugo:3:10
06: RPAREN      : &quot;)&quot;                  // ../hello.ugo:3:11
07: LBRACE      : &quot;{&quot;                  // ../hello.ugo:3:13
08: IDENT       : &quot;exit&quot;               // ../hello.ugo:4:2
09: LPAREN      : &quot;(&quot;                  // ../hello.ugo:4:6
10: NUMBER      : &quot;40&quot;                 // ../hello.ugo:4:7
11: ADD         : &quot;+&quot;                  // ../hello.ugo:4:10
12: NUMBER      : &quot;2&quot;                  // ../hello.ugo:4:12
13: RPAREN      : &quot;)&quot;                  // ../hello.ugo:4:13
14: SEMICOLON   : &quot;&quot;                   // ../hello.ugo:5:1
15: RBRACE      : &quot;}&quot;                  // ../hello.ugo:5:1
16: EOF         : &quot;&quot;                   // ../hello.ugo:5:3
----
00: COMMENT     : &quot;// exit code 42\n&quot;  // ../hello.ugo:4:15
</code></pre>
<p>输出的记号不仅仅有记号类型、记号面值、还有行列号位置信息（在VSCode环境可通过鼠标点击位置实现跳转），位置信息非常有助于调试定位问题。</p>
<p>至此，我们我们实现了将µGo程序的字符流转化为了正常记号和注释记号的两个词法流。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="34-完善语法解析器"><a class="header" href="#34-完善语法解析器">3.4 完善语法解析器</a></h1>
<p>本章在前一章最小µGo程序产生的token.Token序列基础之上通过解析语法产生AST语法树。</p>
<h2 id="341-最小µgo程序的词法序列"><a class="header" href="#341-最小µgo程序的词法序列">3.4.1 最小µGo程序的词法序列</a></h2>
<p>最小µGo程序如下：</p>
<pre><code class="language-go">package main

func main() {
	exit(40+2) // 退出码 42
}
</code></pre>
<p>基于前一章的词法解析程序将产生以下的token.Token列表：</p>
<pre><code class="language-go">
import &quot;github.com/chai2010/ugo/token&quot;

var ugoTokens = []token.Token {
	{Type: token.PACKAGE},                          // package
	{Type: token.IDENT, Literal: &quot;main&quot;},           // main
	{Type: token.SEMICOLON},                        // \n =&gt; ;
	{Type: token.FUNC},                             // func
	{Type: token.IDENT, Literal: &quot;main&quot;},           // main
	{Type: token.LPAREN},                           // (
	{Type: token.RPAREN},                           // )
	{Type: token.LBRACE},                           // {
	{Type: token.IDENT, Literal: &quot;exit&quot;},           // exit
	{Type: token.LPAREN},                           // (
	{Type: token.NUMBER, Literal: &quot;40&quot;, Value: 40}, // 40
	{Type: token.ADD},                              // +
	{Type: token.NUMBER, Literal: &quot;2&quot;, Value: 2},   // 2
	{Type: token.RPAREN},                           // )
	{Type: token.SEMICOLON},                        // \n =&gt; ;
	{Type: token.RBRACE},                           // }
}
</code></pre>
<p>消费这个序列产生AST语法树是本节的目标。</p>
<h2 id="342-tokenstream"><a class="header" href="#342-tokenstream">3.4.2 TokenStream</a></h2>
<p>这个token.Token列表和词法解析器要处理的字符列表并没有本质的区别，因此我们同样可以构造和源文件SourceStream类似的TokenStream对象简化语法的解析工作。</p>
<p>TokenStream的API如下：</p>
<pre><code class="language-go">type TokenStream struct {}

func NewTokenStream(tokens []token.Token) *TokenStream

func (p *TokenStream) PeekToken() token.Token
func (p *TokenStream) ReadToken() token.Token
func (p *TokenStream) UnreadToken()

func (p *TokenStream) AcceptToken(expectTypes ...token.TokenType) (tok token.Token, ok bool)
func (p *TokenStream) AcceptTokenList(expectTypes ...token.TokenType) (toks []token.Token, ok bool)

func (p *TokenStream) MustAcceptToken(expectTypes ...token.TokenType) (tok token.Token)
func (p *TokenStream) MustAcceptTokenList(expectTypes ...token.TokenType) (toks []token.Token)
</code></pre>
<p>NewTokenStream主要基于普通记号序列构造TokenStream对象（目前注释记号并不参与复杂的解析工作，暂时忽略）。PeekToken、ReadToken、UnreadToken分别是预取一个记号、读取一个记号和回退一个记号。AcceptToken尝试消费一个存在于expectTypes中的一个记号，而MustAcceptTokenList则会尝试尽量消费多个满足的记号，它们都返回成功获取的记号值。而MustAcceptToken和MustAcceptTokenList则必须至少成功消费一个满足的记号，否则将通过panic抛出错误（语法解析函数会捕获这类异常并转化为错误返回值）。</p>
<p>最基础的ReadToken和UnreadToken实现如下：</p>
<pre><code class="language-go">type TokenStream struct {
	tokens   []token.Token
	comments []token.Token
	pos      int
	width    int
}

func (p *TokenStream) ReadToken() token.Token {
	if p.pos &gt;= len(p.tokens) {
		p.width = 0
		return token.Token{Type: token.EOF}
	}
	tok := p.tokens[p.pos]
	p.width = 1
	p.pos += p.width
	return tok
}

func (p *TokenStream) UnreadToken() {
	p.pos -= p.width
	return
}
</code></pre>
<p>ReadToken方法会解码并读一个记号，其中<code>p.width</code>用于控制UnreadToken回退操作，它们的实现方式和SourceStream的Read、Unread方法类似。</p>
<p>基于ReadToken和UnreadToken就可以很容易实现PeekToken等其他方法：</p>
<pre><code class="language-go">func (p *TokenStream) PeekToken() token.Token {
	tok := p.ReadToken()
	p.UnreadToken()
	return tok
}

func (p *TokenStream) AcceptToken(expectTypes ...token.TokenType) (tok token.Token, ok bool) {
	tok = p.ReadToken()
	for _, x := range expectTypes {
		if tok.Type == x {
			return tok, true
		}
	}
	p.UnreadToken()
	return tok, false
}

func (p *TokenStream) AcceptTokenList(expectTypes ...token.TokenType) (toks []token.Token, ok bool) {
	for {
		tok, ok := p.AcceptToken(expectTypes...)
		if !ok || tok.Type == token.EOF {
			return toks, len(toks) != 0
		}
		toks = append(toks, tok)
	}
}
</code></pre>
<p>PeekToken等方法先用ReadToken进行正常读取，如果失败则调用UnreadToken回退最近一次的Read操作。</p>
<p>为了简化错误处理，两个Must方法实现如下：</p>
<pre><code class="language-go">func (p *TokenStream) MustAcceptToken(expectTypes ...token.TokenType) (tok token.Token) {
	tok, ok := p.AcceptToken(expectTypes...)
	if !ok {
		panic(fmt.Errorf(&quot;expect %v, got %v&quot;, expectTypes, tok))
	}
	return tok
}

func (p *TokenStream) MustAcceptTokenList(expectTypes ...token.TokenType) (toks []token.Token) {
	toks, ok := p.AcceptTokenList(expectTypes...)
	if !ok {
		panic(fmt.Errorf(&quot;expect %v, got %v&quot;, expectTypes, tok))
	}
	return toks
}
</code></pre>
<p>通过panic可以轻松从多层递归嵌套的语法解析函数中返回，由外层函数将panic再转换为错误返回。</p>
<h2 id="343-构造解析器parser对象"><a class="header" href="#343-构造解析器parser对象">3.4.3 构造解析器Parser对象</a></h2>
<p>Parser对象用于维护解析器内部状态，同时包装了词法解析器并在此基础上实现语法解析功能。Parser定义如下：</p>
<pre><code class="language-go">type Parser struct {
	filename string
	src      string

	*TokenStream
	file *ast.File
	err  error
}
</code></pre>
<p>Parser对象的filename和src对应文件名和文件内容，TokenStream用于包装记号流对象，file则用于保存解析得到的AST语法树，err用于记录错误。</p>
<p>为了统一产生错误，Parser还提供了一个errorf函数：</p>
<pre><code class="language-go">func (p *Parser) errorf(pos int, format string, args ...interface{}) {
	p.err = fmt.Errorf(&quot;%s: %s&quot;,
		lexer.PosString(p.filename, p.src, pos),
		fmt.Sprintf(format, args...),
	)
	panic(p.err)
}
</code></pre>
<p>将错误格式化之后保存到p.err，然后panic抛出异常。</p>
<p>解析文件通过ParseFile方法实现：</p>
<pre><code class="language-go">func (p *Parser) ParseFile() (file *ast.File, err error) {
	defer func() {
		if r := recover(); r != p.err {
			panic(r)
		}
		file, err = p.file, p.err
	}()

	tokens, comments := lexer.Lex(p.filename, p.src)
	for _, tok := range tokens {
		if tok.Type == token.ERROR {
			p.errorf(tok.Pos, &quot;invalid token: %s&quot;, tok.Literal)
		}
	}

	p.TokenStream = NewTokenStream(p.filename, p.src, tokens, comments)
	p.parseFile()

	return
}
</code></pre>
<p>首先在defer函数捕获p.errorf产生的异常并作为错误返回。然后通过lexer.Lex将源文件解析为记号序列，并过滤其中的错误记号。有了正确的记号序列之后通过NewTokenStream构造TokenStream记号流读取对象。最后通过p.parseFile()进行文件语法树解析。</p>
<h3 id="3431-解析文件"><a class="header" href="#3431-解析文件">3.4.3.1 解析文件</a></h3>
<p>解析语法树的过程和写Go代码的过程，根据语法结构对应解析即可：</p>
<pre><code class="language-go">func (p *Parser) parseFile() {
	p.file = &amp;ast.File{}

	// package xxx
	p.file.Pkg = p.parsePackage()

	for {
		switch tok := p.PeekToken(); tok.Type {
		case token.EOF:
			return
		case token.ERROR:
			panic(tok)
		case token.SEMICOLON:
			p.AcceptTokenList(token.SEMICOLON)

		case token.FUNC:
			p.file.Funcs = append(p.file.Funcs, p.parseFunc())

		default:
			p.errorf(tok.Pos, &quot;unknown token: %v&quot;, tok)
		}
	}
}
</code></pre>
<p>首先初始化p.file对象，然后通过p.parsePackage()解析<code>package xxx</code>对应的包定义。然后在for循环中解析全局的对象，目前我们只要处理func定义即可。在没一层选择递归入口的时候，首先通过p.PeekToken()预取一个记号，然后根据记号的类型选择不同的递归函数（因为是手写解析器，我们可以很容易向前看多个记号，实现一些更灵活的语法解析）。</p>
<p>目前只处理EOF、ERROR、SEMICOLON和FUNC等类型，其他未知的记号作为错误处理。对于FUNC分号，AcceptTokenList可以消费多个连续的分号。对于FUNC函数，通过p.parseFunc()解析，并将解析得到的函数添加到p.file.Funcs函数列表中。</p>
<h3 id="3432-解析包定义"><a class="header" href="#3432-解析包定义">3.4.3.2 解析包定义</a></h3>
<p>包的解析非常简单：</p>
<pre><code class="language-go">func (p *Parser) parsePackage() *ast.Package {
	tokPkg := p.MustAcceptToken(token.PACKAGE)
	tokPkgIdent := p.MustAcceptToken(token.IDENT)

	return &amp;ast.Package{
		PkgPos:  tokPkg.Pos,
		NamePos: tokPkgIdent.Pos,
		Name:    tokPkgIdent.Literal,
	}
}
</code></pre>
<p>通过MustAcceptToken方法强制匹配package和包名，然后返回。</p>
<h3 id="3433-解析函数"><a class="header" href="#3433-解析函数">3.4.3.3 解析函数</a></h3>
<p>目前最小µGo程序只有一个main函数，没有函数参数和返回值，函数的解析也是比较直观的：</p>
<pre><code class="language-go">func (p *Parser) parseFunc() *ast.Func {
	// func main()
	tokFunc := p.MustAcceptToken(token.FUNC)
	tokFuncIdent := p.MustAcceptToken(token.IDENT)
	p.MustAcceptToken(token.LPAREN) // (
	p.MustAcceptToken(token.RPAREN) // )

	body := p.parseStmt_block()

	return &amp;ast.Func{
		FuncPos: tokFunc.Pos,
		NamePos: tokFuncIdent.Pos,
		Name:    tokFuncIdent.Literal,
		Body:    body, // {}
	}
}
</code></pre>
<p>同样用MustAcceptToken方法一次强制匹配func、函数名、<code>(</code>、<code>)</code>，然后通过p.parseStmt_block()解析函数体。</p>
<h3 id="3434-解析block"><a class="header" href="#3434-解析block">3.4.3.4 解析Block</a></h3>
<p>函数Body对应一个Block块语句，块语句内由N个语句组成（可以递归包含块语句），解析如下：</p>
<pre><code class="language-go">func (p *Parser) parseStmt_block() *ast.BlockStmt {
	block := &amp;ast.BlockStmt{}

	tokBegin := p.MustAcceptToken(token.LBRACE) // {

Loop:
	for {
		switch tok := p.PeekToken(); tok.Type {
		case token.EOF:
			break Loop
		case token.ERROR:
			p.errorf(tok.Pos, &quot;invalid token: %s&quot;, tok.Literal)
		case token.SEMICOLON:
			p.AcceptTokenList(token.SEMICOLON)

		case token.RBRACE: // }
			break Loop

		default:
			block.List = append(block.List, p.parseStmt_expr())
		}
	}

	tokEnd := p.MustAcceptToken(token.RBRACE) // }

	block.Lbrace = tokBegin.Pos
	block.Rbrace = tokEnd.Pos

	return block
}
</code></pre>
<p>块语句可能包含多个语句，因此通过for循环内实现解析。块内的子语句在switch的default分支解析：p.parseStmt_expr()解析一个表达式语句，并将结果添加到block.List子语句列表中。</p>
<p>函数返回前记得通过p.MustAcceptToken吃掉结尾的<code>}</code>记号。</p>
<h3 id="3435-解析表达式语句"><a class="header" href="#3435-解析表达式语句">3.4.3.5 解析表达式语句</a></h3>
<p>表达式语句基于parseExpr方法实现：</p>
<pre><code class="language-go">func (p *Parser) parseStmt_expr() *ast.ExprStmt {
	return &amp;ast.ExprStmt{
		X: p.parseExpr(),
	}
}
</code></pre>
<p>parseExpr方法用于解析一个表达式，在第2章已经详细讨论过，只要将返回值改造为AST的结构就可以，这里就不展开了。</p>
<h3 id="3436-parsefile"><a class="header" href="#3436-parsefile">3.4.3.6 ParseFile</a></h3>
<p>为了方便使用，再包装一个ParseFile函数：</p>
<pre><code class="language-go">func ParseFile(filename, src string) (*ast.File, error) {
	p := NewParser(filename, src)
	return p.ParseFile()
}
</code></pre>
<p>函数风格和Go语言的<code>go/parser</code>包的ParseFile函数类似。</p>
<h2 id="344-组装编译器"><a class="header" href="#344-组装编译器">3.4.4 组装编译器</a></h2>
<p>现在我们已经完成了语法树解析器的实现，只要对接上后端的编译代码就可以实现从µGo代码到本地可执行程序的编译工作了。</p>
<p>构造以下代码：</p>
<pre><code class="language-go">func main() {
	code := loadCode(&quot;./hello.ugo&quot;)
	f, err := parser.ParseFile(&quot;./hello.ugo&quot;, code)
	if err != nil {
		panic(err)
	}

	ll := new(compiler.Compiler).Compile(f)
	fmt.Print(ll)
}

func loadCode(filename string) string {
	data, err := os.ReadFile(filename)
	if err != nil {
		panic(err)
	}
	return string(data)
}
</code></pre>
<p>该程序将µGo代码输出为LLVM的汇编程序a.out.ll，然后结合clang编译为本地可执行程序并执行：</p>
<pre><code>$ go run main.go &gt; a.out.ll
$ clang -Wno-override-module ./a.out.ll ./builtin/_builtin.ll
$ ./a.out || echo $?
ugo_builtin_exit(42)
42
</code></pre>
<p>这样我们就实现了从最小µGo程序到可执行程序的编译工作。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="35-打印ast语法树"><a class="header" href="#35-打印ast语法树">3.5 打印AST语法树</a></h1>
<p>我们已经实现了µGo程序的语法树解析，为了方便调试我们经常需要打印语法树。本节将为语法树实现格式化打印支持。</p>
<h2 id="351-打印json"><a class="header" href="#351-打印json">3.5.1 打印JSON</a></h2>
<p>最简单的打印AST方式是输出JSON格式，为<code>ast.File</code>增加<code>JSONString</code>方法如下：</p>
<pre><code class="language-go">package ast

func (p *File) JSONString() string {
	file := *p
	if len(file.Source) &gt; 8 {
		file.Source = file.Source[:8] + &quot;...&quot;
	}
	d, _ := json.MarshalIndent(&amp;file, &quot;&quot;, &quot;    &quot;)
	return string(d)
}
</code></pre>
<p>为了减少<code>ast.File.Source</code>的干扰，当µGo源代码较长时用省略号表示。然后通过json.MarshalIndent打印缩进格式的JSON。</p>
<p>构造测试函数：</p>
<pre><code class="language-go">func main() {
	code := loadCode(&quot;../hello.ugo&quot;)
	f, err := parser.ParseFile(&quot;../hello.ugo&quot;, code)
	if err != nil {
		panic(err)
	}

	fmt.Println(f.JSONString())
}

func loadCode(filename string) string {
	data, err := os.ReadFile(filename)
	if err != nil {
		panic(err)
	}
	return string(data)
}
</code></pre>
<p>输入JSON如下：</p>
<pre><code class="language-json">{
    &quot;Filename&quot;: &quot;../hello.ugo&quot;,
    &quot;Source&quot;: &quot;package ...&quot;,
    &quot;Pkg&quot;: {
        &quot;PkgPos&quot;: 1,
        &quot;NamePos&quot;: 9,
        &quot;Name&quot;: &quot;main&quot;
    },
    &quot;Funcs&quot;: [
        {
            &quot;FuncPos&quot;: 15,
            &quot;NamePos&quot;: 20,
            &quot;Name&quot;: &quot;main&quot;,
            &quot;Body&quot;: {
                &quot;Lbrace&quot;: 27,
                &quot;List&quot;: [
                    {
                        &quot;X&quot;: {
                            &quot;FuncName&quot;: &quot;exit&quot;,
                            &quot;Lparen&quot;: 34,
                            &quot;Args&quot;: [
                                {
                                    &quot;OpPos&quot;: 38,
                                    &quot;Op&quot;: 7,
                                    &quot;X&quot;: {
                                        &quot;ValuePos&quot;: 35,
                                        &quot;ValueEnd&quot;: 37,
                                        &quot;Value&quot;: 40
                                    },
                                    &quot;Y&quot;: {
                                        &quot;ValuePos&quot;: 40,
                                        &quot;ValueEnd&quot;: 41,
                                        &quot;Value&quot;: 2
                                    }
                                }
                            ],
                            &quot;Rparen&quot;: 41
                        }
                    }
                ],
                &quot;Rbrace&quot;: 59
            }
        }
    ]
}
</code></pre>
<p>JSON数据忠实地反映了AST中的数据。但是JSON丢失了AST成员的类型信息，同时Pos显示为数字不够直观。因此JSON更适合程序之间交换数据，对于调试AST需求JSON依然不够直观。</p>
<h2 id="352-打印-pos"><a class="header" href="#352-打印-pos">3.5.2 打印 Pos</a></h2>
<p>为了更好地展示 Pos 信息，我们新定义 <code>token.Pos</code> 类型：</p>
<pre><code class="language-go">package token

// Pos 类似一个指针, 表示文件中的位置.
type Pos int

// NoPos 类似指针的 nil 值, 表示一个无效的位置.
const NoPos Pos = 0

func (p Pos) IsValid() bool { return p != NoPos }
</code></pre>
<p>Pos 是基于 int 类型定义的新类型，类似一种抽象的指针，用于表示文件中的位置偏移量。其中 NoPos 对应 0 表示一个无效的地址（类似一个nil指针），因此有效的 Pos 是从1开始的。</p>
<p>同时增加一个 Position 表示基于行列号的位置信息：</p>
<pre><code class="language-go">type Position struct {
	Filename string // 文件名
	Offset   int    // 偏移量, 从 0 开始
	Line     int    // 行号, 从 1 开始
	Column   int    // 列号, 从 1 开始
}
</code></pre>
<p>结合源代码可以将Pos转换行列号的Position结构：</p>
<pre><code class="language-go">func (pos Pos) Position(filename, src string) Position {
	var p = Position{
		Filename: filename,
		Offset:   int(pos) - 1,
		Line:     1,
		Column:   1,
	}

	for _, c := range []byte(src[:p.Offset]) {
		p.Column++
		if c == '\n' {
			p.Column = 1
			p.Line++
		}
	}

	return p
}
</code></pre>
<p>Position结果有自己的String方法：</p>
<pre><code class="language-go">func (pos Position) String() string {
	s := pos.Filename
	if pos.IsValid() {
		if s != &quot;&quot; {
			s += &quot;:&quot;
		}
		s += fmt.Sprintf(&quot;%d&quot;, pos.Line)
		if pos.Column != 0 {
			s += fmt.Sprintf(&quot;:%d&quot;, pos.Column)
		}
	}
	if s == &quot;&quot; {
		s = &quot;-&quot;
	}
	return s
}
</code></pre>
<p>对应以下几种输出格式：</p>
<pre><code class="language-go">//	file:line:column    valid position with file name
//	file:line           valid position with file name but no column (column == 0)
//	line:column         valid position without file name
//	line                valid position without file name and no column (column == 0)
//	file                invalid position with file name
//	-                   invalid position without file name
</code></pre>
<p>在VSCode等环境中，可以根据<code>file:line:column</code>格式的位置直接跳转到对应的位置，这样可以极大提高调试的效率。</p>
<h2 id="353-改造ast"><a class="header" href="#353-改造ast">3.5.3 改造AST</a></h2>
<p>首先改造AST结构，将其中的<code>token.Token</code>类型改造为<code>token.TokenType</code>和<code>token.Pos</code>表示。目前只有一元和二元表达式需要改造：</p>
<pre><code class="language-go">type BinaryExpr struct {
	Op token.Token // 运算符
	X  Expr        // 左边的运算对象
	Y  Expr        // 右边的运算对象
}

type UnaryExpr struct {
	Op token.Token // 运算符
	X  Expr        // 运算对象
}
</code></pre>
<p>改造后如下：</p>
<pre><code class="language-go">type BinaryExpr struct {
	OpPos token.Pos       // 运算符位置
	Op    token.TokenType // 运算符类型
	X     Expr            // 左边的运算对象
	Y     Expr            // 右边的运算对象
}

// UnaryExpr 表示一个一元表达式.
type UnaryExpr struct {
	OpPos token.Pos       // 运算符位置
	Op    token.TokenType // 运算符类型
	X     Expr            // 运算对象
}
</code></pre>
<p>其次将之前用int类型表示的Pos成员改造为<code>token.Pos</code>类型。这类需要改造的地方比较多，但是改造的工作是类似的。比如表示数字面值的Number改造后如下：</p>
<pre><code class="language-go">type Number struct {
	ValuePos token.Pos
	ValueEnd token.Pos
	Value    int
}
</code></pre>
<p>此外为了方便跟踪函数名和变量名等标识符，我们新增加了<code>ast.Ident</code>结构：</p>
<pre><code class="language-go">type Ident struct {
	NamePos token.Pos
	Name    string
}
</code></pre>
<p>函数调用<code>ast.CallExpr</code>中的<code>FuncName</code>成员就可以用<code>ast.Ident</code>指针表示了：</p>
<pre><code class="language-go">type CallExpr struct {
	FuncName *Ident    // 函数名字
	Lparen   token.Pos // '(' 位置
	Args     []Expr    // 调用参数列表
	Rparen   token.Pos // ')' 位置
}
</code></pre>
<p>AST结构发生变化后，parser包也需要做相应的更新，这类不再详细展开。</p>
<h2 id="354-ast打印"><a class="header" href="#354-ast打印">3.5.4 AST打印</a></h2>
<p>AST语法树中结点类型是固定的，我们可以根据不同的类型分别定制打印。不过打印函数一般只用作调试场景，我们也可以基于反射简化打印的工作。先定义一个内部的printer打印对象：</p>
<pre><code class="language-go">type printer struct {
	output   io.Writer
	filename string
	source   string
	ptrmap   map[interface{}]int
	indent   int
}
</code></pre>
<p>其中output是打印的目标流，filename和source将节点的Pos信息翻译为行列号（如果缺失则忽略位置信息），ptrmap用于处理内部相互引用的对象（目前还没有这种），indent用于控制缩进。</p>
<p>然后基于反射提供一个打印的方法：</p>
<pre><code class="language-go">func (p *printer) print(x reflect.Value) {
	switch x.Kind() {
	case reflect.Interface:
		p.print(x.Elem())

	case reflect.Map:
		// TODO
	case reflect.Ptr:
		// TODO
	case reflect.Array:
		// TODO
	case reflect.Slice:
		// TODO
	case reflect.Struct:
		// TODO

	default:
		// TODO
	}
}
</code></pre>
<p>如果是接口则直接递归调用print方法打印对应的元素，其他map、指针、数组、切片、结构等也分开处理即可。</p>
<p>map的打印如下：</p>
<pre><code class="language-go">	case reflect.Map:
		p.printf(&quot;%s (len = %d) {&quot;, x.Type(), x.Len())
		if x.Len() &gt; 0 {
			p.indent++
			p.printf(&quot;\n&quot;)
			for _, key := range x.MapKeys() {
				p.print(key)
				p.printf(&quot;: &quot;)
				p.print(x.MapIndex(key))
				p.printf(&quot;\n&quot;)
			}
			p.indent--
		}
		p.printf(&quot;}&quot;)
</code></pre>
<p>p.printf是打印对象包装的格式化打印函数，然后控制缩进并打印map的key-value对。</p>
<p>指针类型打印方式如下：</p>
<pre><code class="language-go">	case reflect.Ptr:
		p.printf(&quot;*&quot;)
		ptr := x.Interface()
		if line, exists := p.ptrmap[ptr]; exists {
			p.printf(&quot;(obj @ %d)&quot;, line)
		} else {
			p.ptrmap[ptr] = p.line
			p.print(x.Elem())
		}
</code></pre>
<p>其中关键点是需要记录制作到p.ptrmap中，如果第一次出现则打印，否则打印引用第一次打印该对象的行号。</p>
<p>数组和切片的打印方式类似：</p>
<pre><code class="language-go">	case reflect.Array:
		p.printf(&quot;%s {&quot;, x.Type())
		if x.Len() &gt; 0 {
			p.indent++
			p.printf(&quot;\n&quot;)
			for i, n := 0, x.Len(); i &lt; n; i++ {
				p.printf(&quot;%d: &quot;, i)
				p.print(x.Index(i))
				p.printf(&quot;\n&quot;)
			}
			p.indent--
		}
		p.printf(&quot;}&quot;)

	case reflect.Slice:
		if s, ok := x.Interface().([]byte); ok {
			p.printf(&quot;%#q&quot;, s)
			return
		}
		p.printf(&quot;%s (len = %d) {&quot;, x.Type(), x.Len())
		if x.Len() &gt; 0 {
			p.indent++
			p.printf(&quot;\n&quot;)
			for i, n := 0, x.Len(); i &lt; n; i++ {
				p.printf(&quot;%d: &quot;, i)
				p.print(x.Index(i))
				p.printf(&quot;\n&quot;)
			}
			p.indent--
		}
		p.printf(&quot;}&quot;)
</code></pre>
<p>切片打印的类型包含了长度信息，同时对字节切片做了一定特花处理。然后控制缩进打印数组或切片的元素。</p>
<p>最重要的是结构体的打印：</p>
<pre><code class="language-go">	case reflect.Struct:
		t := x.Type()
		p.printf(&quot;%s {&quot;, t)
		p.indent++
		first := true
		for i, n := 0, t.NumField(); i &lt; n; i++ {
			name := t.Field(i).Name
			value := x.Field(i)
			if p.notNilFilter(name, value) {
				if first {
					p.printf(&quot;\n&quot;)
					first = false
				}
				p.printf(&quot;%s: &quot;, name)
				p.print(value)
				p.printf(&quot;\n&quot;)
			}
		}
		p.indent--
		p.printf(&quot;}&quot;)
</code></pre>
<p>遍历结构体的成员，然后和map类似的方式打印其中内容。为了减少语法树中空指针的影响，通过p.notNilFilter做了简单的过滤，其实现如下：</p>
<pre><code class="language-go">func (p *printer) notNilFilter(_name string, v reflect.Value) bool {
	switch v.Kind() {
	case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:
		return !v.IsNil()
	}
	return true
}
</code></pre>
<p>最后是defaul分支的打印：</p>
<pre><code class="language-go">	default:
		v := x.Interface()
		switch v := v.(type) {
		case string:
			// print strings in quotes
			p.printf(&quot;%q&quot;, v)
			return
		case token.Pos:
			if p.filename != &quot;&quot; &amp;&amp; p.source != &quot;&quot; {
				p.printf(&quot;%s&quot;, v.Position(p.filename, p.source))
				return
			}
		}
		// default
		p.printf(&quot;%v&quot;, v)
	}
</code></pre>
<p>对应字符串和Pos做了特殊的格式化处理。</p>
<h2 id="355-包装打印函数"><a class="header" href="#355-包装打印函数">3.5.5 包装打印函数</a></h2>
<p>包装一个Print打印函数，打印任意的语法树结点</p>
<pre><code class="language-go">func Fprint(w io.Writer, filename, source string, node Node) {
	fprint(w, filename, source, node)
}

func fprint(w io.Writer, filename, source string, x interface{}) (err error) {
	p := printer{
		output:   w,
		filename: filename,
		source:   source,
		ptrmap:   make(map[interface{}]int),
		last:     '\n', // force printing of line number on first line
	}

	// print x
	if x == nil {
		p.printf(&quot;nil\n&quot;)
		return
	}
	p.print(reflect.ValueOf(x))
	p.printf(&quot;\n&quot;)
	return
}
</code></pre>
<p>并为File包装一个String方法：</p>
<pre><code class="language-go">func (p *File) String() string {
	var buf bytes.Buffer
	Fprint(&amp;buf, p.Filename, p.Source, p)
	return buf.String()
}
</code></pre>
<h2 id="356-测试打印效果"><a class="header" href="#356-测试打印效果">3.5.6 测试打印效果</a></h2>
<p>现在可以用<code>fmt.Println(f.String())</code>打印文件，输出结果如下：</p>
<pre><code>     0  ast.File {
     1  .  Filename: &quot;../hello.ugo&quot;
     2  .  Source: &quot;package ...&quot;
     3  .  Pkg: *ast.Package {
     4  .  .  PkgPos: ../hello.ugo:1:1
     5  .  .  NamePos: ../hello.ugo:1:9
     6  .  .  Name: &quot;main&quot;
     7  .  }
     8  .  Funcs: []*ast.Func (len = 1) {
     9  .  .  0: *ast.Func {
    10  .  .  .  FuncPos: ../hello.ugo:3:1
    11  .  .  .  NamePos: ../hello.ugo:3:6
    12  .  .  .  Name: &quot;main&quot;
    13  .  .  .  Body: *ast.BlockStmt {
    14  .  .  .  .  Lbrace: ../hello.ugo:3:13
    15  .  .  .  .  List: []ast.Stmt (len = 1) {
    16  .  .  .  .  .  0: *ast.ExprStmt {
    17  .  .  .  .  .  .  X: *ast.CallExpr {
    18  .  .  .  .  .  .  .  FuncName: *ast.Ident {
    19  .  .  .  .  .  .  .  .  NamePos: ../hello.ugo:4:2
    20  .  .  .  .  .  .  .  .  Name: &quot;exit&quot;
    21  .  .  .  .  .  .  .  }
    22  .  .  .  .  .  .  .  Lparen: ../hello.ugo:4:6
    23  .  .  .  .  .  .  .  Args: []ast.Expr (len = 1) {
    24  .  .  .  .  .  .  .  .  0: *ast.BinaryExpr {
    25  .  .  .  .  .  .  .  .  .  OpPos: ../hello.ugo:4:10
    26  .  .  .  .  .  .  .  .  .  Op: +
    27  .  .  .  .  .  .  .  .  .  X: *ast.Number {
    28  .  .  .  .  .  .  .  .  .  .  ValuePos: ../hello.ugo:4:7
    29  .  .  .  .  .  .  .  .  .  .  ValueEnd: ../hello.ugo:4:9
    30  .  .  .  .  .  .  .  .  .  .  Value: 40
    31  .  .  .  .  .  .  .  .  .  }
    32  .  .  .  .  .  .  .  .  .  Y: *ast.Number {
    33  .  .  .  .  .  .  .  .  .  .  ValuePos: ../hello.ugo:4:12
    34  .  .  .  .  .  .  .  .  .  .  ValueEnd: ../hello.ugo:4:13
    35  .  .  .  .  .  .  .  .  .  .  Value: 2
    36  .  .  .  .  .  .  .  .  .  }
    37  .  .  .  .  .  .  .  .  }
    38  .  .  .  .  .  .  .  }
    39  .  .  .  .  .  .  .  Rparen: ../hello.ugo:4:13
    40  .  .  .  .  .  .  }
    41  .  .  .  .  .  }
    42  .  .  .  .  }
    43  .  .  .  .  Rbrace: ../hello.ugo:5:1
    44  .  .  .  }
    45  .  .  }
    46  .  }
    47  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="36-命令行界面"><a class="header" href="#36-命令行界面">3.6 命令行界面</a></h1>
<p>本节的目标是将目前功能还比较松散简陋的编译器包装为好用一点的ugo命令，这样更方便测试和遇到便于问题时定位。</p>
<h2 id="361-最小µgo程序再前进一步"><a class="header" href="#361-最小µgo程序再前进一步">3.6.1 最小µGo程序再前进一步</a></h2>
<p>我们先看看本节可以编译执行的稍微复杂一点的程序：</p>
<pre><code class="language-go">package main

func main() {
	println(1)
	println(1000 + 123)
	println(40 + 2)
}
</code></pre>
<p>使用ugo程序直接执行：</p>
<pre><code>$ ugo run ./hello.ugo 
1
1123
42
</code></pre>
<p>看起来还不错。</p>
<h2 id="362-ugo的命令行界面"><a class="header" href="#362-ugo的命令行界面">3.6.2 ugo的命令行界面</a></h2>
<p>和Go社区习惯一致，使用<code>-h</code>查看帮助：</p>
<pre><code>$ ugo -h
NAME:
   ugo - ugo is a tool for managing µGo source code.

USAGE:
   ugo [global options] command [command options] [arguments...]

VERSION:
   0.0.1

COMMANDS:
   run      compile and run µGo program
   build    compile µGo source code
   lex      lex µGo source code and print token list
   ast      parse µGo source code and print ast
   asm      parse µGo source code and print llvm-ir
   help, h  Shows a list of commands or help for one command

GLOBAL OPTIONS:
   --debug, -d     set debug mode (default: false)
   --help, -h      show help (default: false)
   --version, -v   print the version (default: false)
$
</code></pre>
<p>这是基于cli包构建的命令行界面：run用于编译加执行、build构建本地可执行程序、lex输出词法分析结果、ast输出语法树结果、asm输出语法树翻译为LLVM汇编语言的结果。</p>
<h2 id="363-实现ugo命令---main函数"><a class="header" href="#363-实现ugo命令---main函数">3.6.3 实现ugo命令 - main函数</a></h2>
<p>main函数通过cli包定义子命令和相关的参数：</p>
<pre><code class="language-go">package main

import &quot;github.com/urfave/cli/v2&quot;
import &quot;github.com/chai2010/ugo/build&quot;

func main() {
	app := cli.NewApp()
	app.Name = &quot;ugo&quot;
	app.Usage = &quot;ugo is a tool for managing µGo source code.&quot;
	app.Version = &quot;0.0.1&quot;

	app.Flags = []cli.Flag{
		&amp;cli.StringFlag{Name: &quot;goos&quot;, Usage: &quot;set GOOS&quot;, Value: runtime.GOOS},
		&amp;cli.StringFlag{Name: &quot;goarch&quot;, Usage: &quot;set GOARCH&quot;, Value: runtime.GOARCH},
		&amp;cli.StringFlag{Name: &quot;clang&quot;, Value: &quot;&quot;, Usage: &quot;set clang&quot;},
		&amp;cli.BoolFlag{Name: &quot;debug&quot;, Aliases: []string{&quot;d&quot;}, Usage: &quot;set debug mode&quot;},
	}
</code></pre>
<p>首先是<code>cli.NewApp()</code>定义主命令对象，然后设置名字、提示信息、版本和参数。参数中goos和goarch用于指定目标平台（目前还没有用到），clang则用于支持用户自定义的路径，debug表示调试模式。</p>
<p>然后是定义全部的子命令：</p>
<pre><code class="language-go">	app.Commands = []*cli.Command{
		{
			Name:  &quot;run&quot;,
			Usage: &quot;compile and run µGo program&quot;,
			Action: func(c *cli.Context) error {
				ctx := build.NewContext(build_Options(c))
				output, _ := ctx.Run(c.Args().First(), nil)
				fmt.Print(string(output))
				return nil
			},
		},
		{
			Name:  &quot;build&quot;,
			Usage: &quot;compile µGo source code&quot;,
			Action: func(c *cli.Context) error {
				ctx := build.NewContext(build_Options(c))
				ctx.Build(c.Args().First(), nil, &quot;a.out&quot;)
				return nil
			},
		},
		{
			Name:  &quot;lex&quot;,
			Usage: &quot;lex µGo source code and print token list&quot;,
			Action: func(c *cli.Context) error {
				ctx := build.NewContext(build_Options(c))
				tokens, comments, _ := ctx.Lex(c.Args().First(), nil)
				fmt.Println(tokens)
				fmt.Println(comments)
				return nil
			},
		},
		{
			Name:  &quot;ast&quot;,
			Usage: &quot;parse µGo source code and print ast&quot;,
			Flags: []cli.Flag{
				&amp;cli.BoolFlag{Name: &quot;json&quot;, Usage: &quot;output json format&quot;},
			},
			Action: func(c *cli.Context) error {
				ctx := build.NewContext(build_Options(c))
				f, err := ctx.AST(c.Args().First(), nil)
				if c.Bool(&quot;json&quot;) {
					fmt.Println(f.JSONString())
				} else {
					fmt.Println(f.String())
				}
				return nil
			},
		},
		{
			Name:  &quot;asm&quot;,
			Usage: &quot;parse µGo source code and print llvm-ir&quot;,
			Action: func(c *cli.Context) error {
				ctx := build.NewContext(build_Options(c))
				ll, _ := ctx.ASM(c.Args().First(), nil)
				fmt.Println(ll)
				return nil
			},
		},
	}

	app.Run(os.Args)
}
</code></pre>
<p>对应run、build、lex、ast和asm几个子命令，具体的实现是由build包的Context对象提供的对应方法实现。最后调用<code>app.Run(os.Args)</code>执行命令行。build_Options函数负责从全局参数解析信息，产生执行需要的上下文参数。</p>
<h2 id="364-实现ugo命令---buildcontext对象"><a class="header" href="#364-实现ugo命令---buildcontext对象">3.6.4 实现ugo命令 - build.Context对象</a></h2>
<p>build.Context对象是当前执行命令需要的参数包装：</p>
<pre><code class="language-go">package build

type Option struct {
	Debug  bool
	GOOS   string
	GOARCH string
	Clang  string
}

type Context struct {
	opt  Option
	path string
	src  string
}
</code></pre>
<p>除了目标平台信息，还包含ugo代码的路径。</p>
<p>词法解析方法实现如下：</p>
<pre><code class="language-go">func (p *Context) Lex(filename string, src interface{}) (tokens, comments []token.Token, err error) {
	code, err := p.readSource(filename, src)
	if err != nil {
		return nil, nil, err
	}

	l := lexer.NewLexer(filename, code)
	tokens = l.Tokens()
	comments = l.Comments()
	return
}
</code></pre>
<p>语法树解析方法包装：</p>
<pre><code class="language-go">func (p *Context) AST(filename string, src interface{}) (f *ast.File, err error) {
	code, err := p.readSource(filename, src)
	if err != nil {
		return nil, err
	}

	f, err = parser.ParseFile(filename, code)
	if err != nil {
		return nil, err
	}

	return f, nil
}
</code></pre>
<p>产生LLVM汇编代码的方法包装：</p>
<pre><code class="language-go">func (p *Context) ASM(filename string, src interface{}) (ll string, err error) {
	code, err := p.readSource(filename, src)
	if err != nil {
		return &quot;&quot;, err
	}

	f, err := parser.ParseFile(filename, code)
	if err != nil {
		return &quot;&quot;, err
	}

	ll = new(compiler.Compiler).Compile(f)
	return ll, nil
}
</code></pre>
<p>Build和Run方法定义如下（实现细节就不展开了，具体方式可以参考代码）：</p>
<pre><code class="language-go">func (p *Context) Build(
	filename string, src interface{}, outfile string,
) (output []byte, err error) {
	// ...
}

func (p *Context) Run(filename string, src interface{}) ([]byte, error) {
	// ...
}
</code></pre>
<p>辅助的readSource方法实现如下：</p>
<pre><code class="language-go">func (p *Context) readSource(filename string, src interface{}) (string, error) {
	if src != nil {
		switch s := src.(type) {
		case string:
			return s, nil
		case []byte:
			return string(s), nil
		case *bytes.Buffer:
			if s != nil {
				return s.String(), nil
			}
		case io.Reader:
			d, err := io.ReadAll(s)
			return string(d), err
		}
		return &quot;&quot;, errors.New(&quot;invalid source&quot;)
	}

	d, err := os.ReadFile(filename)
	return string(d), err
}
</code></pre>
<p>这样我们就可以通过指定不同的GOOS和GOARCH实现交叉编译。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="4-作用域和变量"><a class="header" href="#4-作用域和变量">4. 作用域和变量</a></h1>
<p>本章将将引入作用域和变量的支持，我们可以通过赋值语句将中间的结果记录到全局或局部的变量，其中局部变量将会涉及嵌套作用域的处理。从实现角度看，作用域的支持比if和for等分支更为重要——因为作用域将决定如何查找一个名字、这个名字的类型和状态等信息。当然还需要完善语法树解析器，以增加对赋值和嵌套作用域的支持。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="41-完善token包"><a class="header" href="#41-完善token包">4.1 完善token包</a></h1>
<p>在开始改造编译器之前，我们先深刻理解本章新出现语法的细节。</p>
<h2 id="411-变量定义"><a class="header" href="#411-变量定义">4.1.1 变量定义</a></h2>
<p>为了简化问题，我们目前只支持以下几种形式的变量定义：</p>
<pre><code class="language-go">var x1 int
var x2 int = 134
var x3 = 456
</code></pre>
<p>其中x1只有类型，没有初始化值，初始为0值。x2指定类型并通过一个表达式初始化。x3则忽略类型，只有一个初始化表达式。每个var只能定义一个变量。目前假设变量全部都是int类型，底层为32bit的整数。因为涉及全局变量的初始化，最终需要隐式产生一个init函数用于全局变量的初始化工作。</p>
<h2 id="412-嵌套作用域"><a class="header" href="#412-嵌套作用域">4.1.2 嵌套作用域</a></h2>
<p>遍历支持嵌套作用域，内层同名的变量自动屏蔽外层的变量：</p>
<pre><code class="language-go">package main

var x int

func main() {
	x = x + 1

	var x int = x + 10
	{
		println(x)
		var x = x + 100
		println(x)
	}
	println(x)
}
</code></pre>
<p>其中<code>x = x + 1</code>是对main包的x变量加一。<code>var x int = x + 10</code>则是在main函数内重新定义一个局部变量，并用外层的包级的x变量进行初始化。最后一个<code>var x = x + 100</code>是在内层定义一个同名的x变量，并用main函数之前定义x变量进行初始化。</p>
<h2 id="413-定义新的token类型"><a class="header" href="#413-定义新的token类型">4.1.3 定义新的Token类型</a></h2>
<p>本章的例子只新增加了<code>var</code>关键字和<code>=</code>赋值操作符。token包增加以下定义：</p>
<pre><code class="language-go">package token

// 记号类型
type TokenType int

// ch3中 µGo程序用到的记号类型
const (
	EOF TokenType = iota // = 0

	...
	VAR    // var
	ASSIGN // =
	...
)
</code></pre>
<p>同时需要将VAR注册为关键字类型，便于配合<code>token.Lookup</code>函数工作。</p>
<h2 id="414-完善token方法"><a class="header" href="#414-完善token方法">4.1.4 完善Token方法</a></h2>
<p>token.Token表示一个记号的纸：</p>
<pre><code class="language-go">type Token struct {
	Pos     Pos       // 记号所在的位置(从1开始)
	Type    TokenType // 记号的类型
	Literal string    // 程序中原始的字符串
}
</code></pre>
<p>主要是Token出现的位置、Token类型和对应的面值字符串。</p>
<p>对于整数类型的Token，我们还需要将其面值字符串解析为整数值。因此为其定义一个IntValue方法：</p>
<pre><code class="language-go">func (i Token) IntValue() int {
	x, err := strconv.ParseInt(i.Literal, 10, 64)
	if err != nil {
		panic(err)
	}
	return int(x)
}
</code></pre>
<p>如果后面要支持float和string类型时，我们也可以增加对应的辅助方法。</p>
<h2 id="415-完善lex包"><a class="header" href="#415-完善lex包">4.1.5 完善lex包</a></h2>
<p>两个记号的词法解析比较简单。补全词法解析后，解析以下代码：</p>
<pre><code class="language-go">package main

func main() {
	var x = 1 + 2
}
</code></pre>
<p>输出结果如下：</p>
<pre><code class="language-shell">$ go run main.go -debug=false lex ./_examples/hello.ugo
00: package     : &quot;package&quot;            // ./_examples/hello.ugo:1:1
01: IDENT       : &quot;main&quot;               // ./_examples/hello.ugo:1:9
02: ;           : &quot;&quot;                   // ./_examples/hello.ugo:2:1
03: func        : &quot;func&quot;               // ./_examples/hello.ugo:3:1
04: IDENT       : &quot;main&quot;               // ./_examples/hello.ugo:3:6
05: (           : &quot;(&quot;                  // ./_examples/hello.ugo:3:10
06: )           : &quot;)&quot;                  // ./_examples/hello.ugo:3:11
07: {           : &quot;{&quot;                  // ./_examples/hello.ugo:3:13
08: var         : &quot;var&quot;                // ./_examples/hello.ugo:4:2
09: IDENT       : &quot;x&quot;                  // ./_examples/hello.ugo:4:6
10: =           : &quot;=&quot;                  // ./_examples/hello.ugo:4:8
11: NUMBER      : &quot;1&quot;                  // ./_examples/hello.ugo:4:10
12: +           : &quot;+&quot;                  // ./_examples/hello.ugo:4:12
13: NUMBER      : &quot;2&quot;                  // ./_examples/hello.ugo:4:14
14: ;           : &quot;&quot;                   // ./_examples/hello.ugo:5:1
15: }           : &quot;}&quot;                  // ./_examples/hello.ugo:5:1
16: EOF         : &quot;&quot;                   // ./_examples/hello.ugo:6:1
</code></pre>
<p>其中<code>var</code>和<code>=</code>已经成功解析。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="42-完善ast和解析器"><a class="header" href="#42-完善ast和解析器">4.2 完善AST和解析器</a></h1>
<p>Token类型和词法解析的准备工作都就绪了，本节我们将继续完善AST结点定义和语法树的解析工作。</p>
<h2 id="421-完善ast结点"><a class="header" href="#421-完善ast结点">4.2.1 完善AST结点</a></h2>
<p>新增加的VAR和ASSIGN两个Token类型分别对应2个新的语法树结点。</p>
<p>新增 <code>VarSpec</code> 类型表示变量的定义：</p>
<pre><code class="language-go">// 变量信息
type VarSpec struct {
	VarPos token.Pos // var 关键字位置
	Name   *Ident    // 变量名字
	Type   *Ident    // 变量类型, 可省略
	Value  Expr      // 变量表达式
}
</code></pre>
<p>其中重要的信息时变量的名字，变量的类型和变量的初始化值。初始化表达式是一个 Expr 表达式接口类型，可以为空。有初始化表达式时，类型也可以为空。</p>
<p>然后新增加 <code>AssignStmt</code> 表示一个赋值语句（目前只支持一个变量的赋值）：</p>
<pre><code class="language-go">type AssignStmt struct {
	Target *Ident          // 要赋值的目标
	OpPos  token.Pos       // Op 的位置
	Op     token.TokenType // '='
	Value  Expr            // 值
}
</code></pre>
<p>其中Target表示被赋值的目标，Value是值表达式，Op表示赋值的操作符号。目前Op只有<code>=</code>一种情况，之所以添加Op是为了后面支持<code>:=</code>简短定义赋值的语法，目前可以忽略。</p>
<p>最后File增加全局变量的信息：</p>
<pre><code class="language-go">type File struct {
	Filename string // 文件名
	Source   string // 源代码

	Pkg     *PackageSpec // 包信息
	Globals []*VarSpec   // 全局变量
	Funcs   []*Func      // 函数列表
}
</code></pre>
<p>为了好区分，我们将Package类型改名为PackageSpec类型。Globals表示全局变量列表。Funcs依然是函数列表。</p>
<h2 id="422-完善嵌套的块语句解析"><a class="header" href="#422-完善嵌套的块语句解析">4.2.2 完善嵌套的块语句解析</a></h2>
<p>在第3章的例子中我们已经可以实现多个语句的解析，但是还不支持嵌套块语句的解析。比如以下的代码：</p>
<pre><code class="language-go">func main() {
	{
		println(123)
	}
}
</code></pre>
<p>在解析内层的块语句时会出现<code>unknown tok: type={, lit=&quot;{&quot;</code>错误。</p>
<p>块语句由<code>Parser.parseStmt_block</code>方法解析，只需要增加对嵌套块语句处理即可：</p>
<pre><code class="language-go">func (p *Parser) parseStmt_block() *ast.BlockStmt {
	block := &amp;ast.BlockStmt{}
	tokBegin := p.MustAcceptToken(token.LBRACE) // {

Loop:
	for {
		switch tok := p.PeekToken(); tok.Type {
		...
		case token.LBRACE: // {}
			block.List = append(block.List, p.parseStmt_block())
		case token.RBRACE: // }
			break Loop
		...
		}
	}

	tokEnd := p.MustAcceptToken(token.RBRACE) // }

	block.Lbrace = tokBegin.Pos
	block.Rbrace = tokEnd.Pos
	return block
}
</code></pre>
<p>当遇到<code>token.LBRACE</code>左大括弧时递归调用处理子块语句。</p>
<h2 id="423-变量定义解析"><a class="header" href="#423-变量定义解析">4.2.3 变量定义解析</a></h2>
<p>目前只支持以下几种形式的变量定义：</p>
<pre><code class="language-go">var x1 int
var x2 int = 134
var x3 = 456
</code></pre>
<p>增加<code>Parser.parseStmt_var</code>方法解析这3种变量定义的语句：</p>
<pre><code class="language-go">func (p *Parser) parseStmt_var() *ast.VarSpec {
	tokVar := p.MustAcceptToken(token.VAR)
	tokIdent := p.MustAcceptToken(token.IDENT)

	var varSpec = &amp;ast.VarSpec{
		VarPos: tokVar.Pos,
	}

	varSpec.Name = &amp;ast.Ident{
		NamePos: tokIdent.Pos,
		Name:    tokIdent.Literal,
	}

	// var name type?
	if typ, ok := p.AcceptToken(token.IDENT); ok {
		varSpec.Type = &amp;ast.Ident{
			NamePos: typ.Pos,
			Name:    typ.Literal,
		}
	}

	// var name =
	if _, ok := p.AcceptToken(token.ASSIGN); ok {
		varSpec.Value = p.parseExpr()
	}

	p.AcceptTokenList(token.SEMICOLON)
	return varSpec
}
</code></pre>
<p>首先必须匹配<code>var</code>关键字和<code>token.IDENT</code>表示的变量名。然后根据<code>p.AcceptToken(token.IDENT)</code>判断是否有type信息，<code>p.AcceptToken(token.ASSIGN)</code>用于判断是否有初始化表达式，如果有初始化表达式则通过<code>p.parseExpr()</code>解析表达式。</p>
<p>有了变量定义解析之后，就可以在<code>Parser.parseFile</code>中添加对全局变量的解析：</p>
<pre><code class="language-go">func (p *Parser) parseFile() {
	...
	for {
		switch tok := p.PeekToken(); tok.Type {
		...
		case token.VAR:
			p.file.Globals = append(p.file.Globals, p.parseStmt_var())
		case token.FUNC:
			p.file.Funcs = append(p.file.Funcs, p.parseFunc())
		...
		}
	}
}
</code></pre>
<p>如果遇到<code>token.VAR</code>类型的Token，就通过<code>p.parseStmt_var()</code>解析并添加到<code>p.file.Globals</code>。</p>
<p>对于局部变量的解析在<code>Parser.parseStmt_block</code>中完成：</p>
<pre><code class="language-go">func (p *Parser) parseStmt_block() *ast.BlockStmt {
	...
Loop:
	for {
		switch tok := p.PeekToken(); tok.Type {
		...
		case token.VAR:
			block.List = append(block.List, p.parseStmt_var())
		...
		}
	}
	...
}
</code></pre>
<p>在块语句中如果遇到<code>token.VAR</code>类型的Token，则通过<code>p.parseStmt_var()</code>解析变量定义语句，并添加到<code>block.List</code>中。</p>
<h2 id="424-变量和函数名"><a class="header" href="#424-变量和函数名">4.2.4 变量和函数名</a></h2>
<p>之前的代码只支持builtin类型的函数调用，和普通的表达式语句。之前的<code>parseExpr_primary</code>方法在遇到表示符时默认作为函数调用处理：</p>
<pre><code class="language-go">func (p *Parser) parseExpr_primary() ast.Expr {
	...
	switch tok := p.PeekToken(); tok.Type {
	case token.IDENT: // call
		return p.parseExpr_call()
	...
	}
}
</code></pre>
<p>为了支持变量读取，我们需要区分函数调用的函数名字和变量名字。改造代码如下：</p>
<pre><code class="language-go">func (p *Parser) parseExpr_primary() ast.Expr {
	...
	switch tok := p.PeekToken(); tok.Type {
	case token.IDENT: // call
		p.ReadToken()
		nextTok := p.PeekToken()
		p.UnreadToken()

		switch nextTok.Type {
		case token.LPAREN:
			return p.parseExpr_call()
		default:
			p.MustAcceptToken(token.IDENT)
			return &amp;ast.Ident{
				NamePos: tok.Pos,
				Name:    tok.Literal,
			}
		}
	...
	}
}
</code></pre>
<p>通过<code>p.PeekToken()</code>向前多看2个Token，如果第2个是<code>token.LPAREN</code>左小括弧类型的Token则对应函数调用，否则作为普通的标识符处理。</p>
<h2 id="425-赋值语句解析"><a class="header" href="#425-赋值语句解析">4.2.5 赋值语句解析</a></h2>
<p>赋值语句是普通表达式语句到扩展。之前的<code>parseStmt_block</code>解析块语句时，在default分支解析表达式语句：</p>
<pre><code class="language-go">func (p *Parser) parseStmt_block() *ast.BlockStmt {
	...
Loop:
	for {
		switch tok := p.PeekToken(); tok.Type {
		...
		default:
			block.List = append(block.List, p.parseStmt_expr())
		}
	}
	...
}
</code></pre>
<p>在解析完成表达式之后（被赋值的变量名也是一种表达式），向前多看一个Token是否为<code>token.ASSIGN</code>类型的赋值操作符，如果是则继续解析右侧的值表达式。改动后的代码片段如下：</p>
<pre><code class="language-go">func (p *Parser) parseStmt_block() *ast.BlockStmt {
	...
Loop:
	for {
		switch tok := p.PeekToken(); tok.Type {
		...
		default:
			// expr ;
			// target = expr;
			expr := p.parseExpr()
			switch tok := p.PeekToken(); tok.Type {
			case token.SEMICOLON:
				block.List = append(block.List, &amp;ast.ExprStmt{
					X: expr,
				})
			case token.ASSIGN:
				p.ReadToken()
				exprValue := p.parseExpr()
				block.List = append(block.List, &amp;ast.AssignStmt{
					Target: expr.(*ast.Ident),
					OpPos:  tok.Pos,
					Op:     tok.Type,
					Value:  exprValue,
				})

			default:
				p.errorf(tok.Pos, &quot;unknown token: %v&quot;, tok)
			}
		}
	}
	...
}
</code></pre>
<p>目前我们只支持单变量的赋值，如果以后要支持多变量赋值，只要将<code>p.parseExpr()</code>扩展为<code>p.parseExprList()</code>即可。</p>
<h2 id="426-测试ast解析"><a class="header" href="#426-测试ast解析">4.2.6 测试AST解析</a></h2>
<p>构造以下例子：</p>
<pre><code class="language-go">package main

var x1 int
var x2 int = 134

func main() {
	{
		var x2 = x2
		x2 = 100
	}
}
</code></pre>
<p>其中有3种变量定义的形式，和一个内层嵌套的赋值语句。解析结果如下：</p>
<pre><code class="language-shell">$ go run main.go -debug=false ast ./_examples/hello.ugo
     0  ast.File {
     1  .  Filename: &quot;./_examples/hello.ugo&quot;
     2  .  Source: &quot;package ...&quot;
     3  .  Pkg: *ast.PackageSpec {
     4  .  .  PkgPos: ./_examples/hello.ugo:1:1
     5  .  .  NamePos: ./_examples/hello.ugo:1:9
     6  .  .  Name: &quot;main&quot;
     7  .  }
     8  .  Globals: []*ast.VarSpec (len = 2) {
     9  .  .  0: *ast.VarSpec {
    10  .  .  .  VarPos: ./_examples/hello.ugo:3:1
    11  .  .  .  Name: *ast.Ident {
    12  .  .  .  .  NamePos: ./_examples/hello.ugo:3:5
    13  .  .  .  .  Name: &quot;x1&quot;
    14  .  .  .  }
    15  .  .  .  Type: *ast.Ident {
    16  .  .  .  .  NamePos: ./_examples/hello.ugo:3:8
    17  .  .  .  .  Name: &quot;int&quot;
    18  .  .  .  }
    19  .  .  }
    20  .  .  1: *ast.VarSpec {
    21  .  .  .  VarPos: ./_examples/hello.ugo:4:1
    22  .  .  .  Name: *ast.Ident {
    23  .  .  .  .  NamePos: ./_examples/hello.ugo:4:5
    24  .  .  .  .  Name: &quot;x2&quot;
    25  .  .  .  }
    26  .  .  .  Type: *ast.Ident {
    27  .  .  .  .  NamePos: ./_examples/hello.ugo:4:8
    28  .  .  .  .  Name: &quot;int&quot;
    29  .  .  .  }
    30  .  .  .  Value: *ast.Number {
    31  .  .  .  .  ValuePos: ./_examples/hello.ugo:4:14
    32  .  .  .  .  ValueEnd: ./_examples/hello.ugo:4:17
    33  .  .  .  .  Value: 134
    34  .  .  .  }
    35  .  .  }
    36  .  }
    37  .  Funcs: []*ast.Func (len = 1) {
    38  .  .  0: *ast.Func {
    39  .  .  .  FuncPos: ./_examples/hello.ugo:6:1
    40  .  .  .  NamePos: ./_examples/hello.ugo:6:6
    41  .  .  .  Name: &quot;main&quot;
    42  .  .  .  Body: *ast.BlockStmt {
    43  .  .  .  .  Lbrace: ./_examples/hello.ugo:6:13
    44  .  .  .  .  List: []ast.Stmt (len = 1) {
    45  .  .  .  .  .  0: *ast.BlockStmt {
    46  .  .  .  .  .  .  Lbrace: ./_examples/hello.ugo:7:2
    47  .  .  .  .  .  .  List: []ast.Stmt (len = 2) {
    48  .  .  .  .  .  .  .  0: *ast.VarSpec {
    49  .  .  .  .  .  .  .  .  VarPos: ./_examples/hello.ugo:8:3
    50  .  .  .  .  .  .  .  .  Name: *ast.Ident {
    51  .  .  .  .  .  .  .  .  .  NamePos: ./_examples/hello.ugo:8:7
    52  .  .  .  .  .  .  .  .  .  Name: &quot;x2&quot;
    53  .  .  .  .  .  .  .  .  }
    54  .  .  .  .  .  .  .  .  Value: *ast.Ident {
    55  .  .  .  .  .  .  .  .  .  NamePos: ./_examples/hello.ugo:8:12
    56  .  .  .  .  .  .  .  .  .  Name: &quot;x2&quot;
    57  .  .  .  .  .  .  .  .  }
    58  .  .  .  .  .  .  .  }
    59  .  .  .  .  .  .  .  1: *ast.AssignStmt {
    60  .  .  .  .  .  .  .  .  Target: *ast.Ident {
    61  .  .  .  .  .  .  .  .  .  NamePos: ./_examples/hello.ugo:9:3
    62  .  .  .  .  .  .  .  .  .  Name: &quot;x2&quot;
    63  .  .  .  .  .  .  .  .  }
    64  .  .  .  .  .  .  .  .  OpPos: ./_examples/hello.ugo:9:6
    65  .  .  .  .  .  .  .  .  Op: =
    66  .  .  .  .  .  .  .  .  Value: *ast.Number {
    67  .  .  .  .  .  .  .  .  .  ValuePos: ./_examples/hello.ugo:9:8
    68  .  .  .  .  .  .  .  .  .  ValueEnd: ./_examples/hello.ugo:9:11
    69  .  .  .  .  .  .  .  .  .  Value: 100
    70  .  .  .  .  .  .  .  .  }
    71  .  .  .  .  .  .  .  }
    72  .  .  .  .  .  .  }
    73  .  .  .  .  .  .  Rbrace: ./_examples/hello.ugo:10:2
    74  .  .  .  .  .  }
    75  .  .  .  .  }
    76  .  .  .  .  Rbrace: ./_examples/hello.ugo:11:1
    77  .  .  .  }
    78  .  .  }
    79  .  }
    80  }
</code></pre>
<p>有了AST之后，我们就可以考虑如何将变量转化为汇编代码了。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="43-完善llir输出"><a class="header" href="#43-完善llir输出">4.3 完善LLIR输出</a></h1>
<p>基于新的AST语法树翻译到LLVM-IR需要处理嵌套的词法域问题。本节尝试通过Scope实现对嵌套的词法域支持，并完善LLIR输出。</p>
<h2 id="431-词法域等例子"><a class="header" href="#431-词法域等例子">4.3.1 词法域等例子</a></h2>
<p>在不同的词法域空间，同一个名字表示不同的对象。比如：</p>
<pre><code class="language-go">package main

var x int

func main() {
	var x = x + 1
}
</code></pre>
<p>有2个变量名字都是x，最外层的x是包级变量，main函数中新定义1个x局部变量。但是main函数内x变量初始化时，右侧的表达式中的x表示的是外层的包变量x。再向外层还有一个builtin词法域空间。词法域表示基于当前上下文环境检索名字的规则，以及配套的名字符号表。</p>
<h2 id="432-定义词法域"><a class="header" href="#432-定义词法域">4.3.2 定义词法域</a></h2>
<p>词法域属于语义解析，目前只有compiler包产生LLVM汇编代码时需要。因此在compiler包定义Scope管理词法域：</p>
<pre><code class="language-go">package compiler

import &quot;github.com/chai2010/ugo/ast&quot;

type Scope struct {
	Outer   *Scope
	Objects map[string]*Object
}

type Object struct {
	Name        string
	MangledName string
	ast.Node
}

func NewScope(outer *Scope) *Scope {
	return &amp;Scope{outer, make(map[string]*Object)}
}
</code></pre>
<p>Scope内的Outer指向外层的Scope，比如main函数的外层Scope是文件，文件的外层是builtin（目前为了简化忽略了Package级别的Scope）。</p>
<p>Object表示一个命名对象，其中Name是实体在uGo代码中词法域的名字，LLName是映射到LLVM汇编语言的名字。其中还有指向的AST节点，可以用于识别更多的信息。</p>
<p>Scope还需要几个辅助方法：</p>
<pre><code class="language-go">func (s *Scope) HasName(name string) bool {
	_, ok := s.Objects[name]
	return ok
}

func (s *Scope) Lookup(name string) (*Scope, *Object) {
	for ; s != nil; s = s.Outer {
		if obj := s.Objects[name]; obj != nil {
			return s, obj
		}
	}
	return nil, nil
}

func (s *Scope) Insert(obj *Object) (alt *Object) {
	if alt = s.Objects[obj.Name]; alt == nil {
		s.Objects[obj.Name] = obj
	}
	return
}
</code></pre>
<p>其中HasName判断当前词法空间是否包含Name，Lookup则是从内向外层查询符号，Insert用于添加一个新的符号。</p>
<h2 id="433-builtin内置函数"><a class="header" href="#433-builtin内置函数">4.3.3 Builtin内置函数</a></h2>
<p>builtin的Scope对应最外层的宇宙空间：</p>
<pre><code class="language-go">var Universe *Scope = NewScope(nil)

var builtinObjects = []*Object{
	{Name: &quot;println&quot;, MangledName: &quot;@ugo_builtin_println&quot;},
	{Name: &quot;exit&quot;, MangledName: &quot;@ugo_builtin_exit&quot;},
}

func init() {
	for _, obj := range builtinObjects {
		Universe.Insert(obj)
	}
}
</code></pre>
<p>Universe是一个包级别的变量，Universe之外就没有词法域了。我们在包初始化时，向Universe注入了内置的println和exit函数信息。</p>
<p>然后向Compiler对象添加Scope成员：</p>
<pre><code class="language-go">type Compiler struct {
	file   *ast.File
	scope  *Scope
	nextId int
}
</code></pre>
<p>并在编译方法中初始化scope对象：</p>
<pre><code class="language-go">func NewCompiler() *Compiler {
	return &amp;Compiler{
		scope: NewScope(Universe),
	}
}
</code></pre>
<p><code>NewScope(Universe)</code> 基于 Universe 构建，因此也就具备了Builtin预先定义的println和exit内置函数。</p>
<p>内置函数调用翻译现在可以从scope查询了：</p>
<pre><code class="language-go">func (p *Compiler) compileExpr(w io.Writer, expr ast.Expr) (localName string) {
	switch expr := expr.(type) {
	...
	case *ast.CallExpr:
		var fnName string
		if _, obj := p.scope.Lookup(expr.FuncName.Name); obj != nil {
			fnName = obj.MangledName
		} else {
			panic(fmt.Sprintf(&quot;func %s undefined&quot;, expr.FuncName.Name))
		}

		localName = p.genId()
		fmt.Fprintf(w, &quot;\t%s = call i32(i32) %s(i32 %v)\n&quot;,
			localName, fnName, p.compileExpr(w, expr.Args[0]),
		)
		return localName
	...
	}
}
</code></pre>
<p>现在<code>p.scope</code>只有一个Scope，也就是Universe，但是已经可以支持获取内置函数真实的名称了。</p>
<h2 id="434-嵌套scope"><a class="header" href="#434-嵌套scope">4.3.4 嵌套Scope</a></h2>
<p>每个可以定义新变量的词法域都对应一个嵌套的Scope，目前全局变量和每个块语句都对应一个Scope。因此Compiler对象可以定义辅助函数用于进入和退出内层的Scope：</p>
<pre><code class="language-go">func (p *Compiler) enterScope() {
	p.scope = NewScope(p.scope)
}

func (p *Compiler) leaveScope() {
	p.scope = p.scope.Outer
}
</code></pre>
<p>enterScope表示进入新的词法域，leaveScope表示退出当前词法域。</p>
<p>我们需要在编译文件、块语句时进入新的Scope，以便于存储新词法域定义的新变量：</p>
<pre><code class="language-go">func (p *Compiler) compileFile(w io.Writer, file *ast.File) {
	p.enterScope()
	defer p.leaveScope()
	...
}

func (p *Compiler) compileStmt(w io.Writer, stmt ast.Stmt) {
	switch stmt := stmt.(type) {
	...
	case *ast.BlockStmt:
		p.enterScope()
		defer p.leaveScope()
	...
	}
}
</code></pre>
<p>当处理完成退出函数时通过defer语句离开嵌套的词法域。</p>
<h2 id="435-定义全局变量"><a class="header" href="#435-定义全局变量">4.3.5 定义全局变量</a></h2>
<p>定义变量就是向当前的Scope添加新的命名对象，全局变量在编译文件时处理：</p>
<pre><code class="language-go">func (p *Compiler) compileFile(w io.Writer, file *ast.File) {
	p.enterScope()
	defer p.leaveScope()

	for _, g := range file.Globals {
		var mangledName = fmt.Sprintf(&quot;@ugo_%s_%s&quot;, file.Pkg.Name, g.Name.Name)
		p.scope.Insert(&amp;Object{
			Name:        g.Name.Name,
			MangledName: mangledName,
			Node:        g,
		})
		fmt.Fprintf(w, &quot;%s = global i32 0\n&quot;, mangledName)
	}
	...
}
</code></pre>
<p>通过遍历<code>file.Globals</code>处理每个全局变量。mangledName是全局变量修饰后在LLVM汇编中的名字，以<code>@ugo_</code>开头连接包名和变量名组成（包名有冲突的风险，更安全的做法是用唯一的包路径替代）。</p>
<h2 id="436-全局函数对象"><a class="header" href="#436-全局函数对象">4.3.6 全局函数对象</a></h2>
<p>全局函数是和全局变量类似的命名对象，可以在compileFunc中处理：</p>
<pre><code class="language-go">func (p *Compiler) compileFunc(w io.Writer, file *ast.File, fn *ast.Func) {
	p.enterScope()
	defer p.leaveScope()

	var mangledName = fmt.Sprintf(&quot;@ugo_%s_%s&quot;, file.Pkg.Name, fn.Name)
	p.scope.Insert(&amp;Object{
		Name:        fn.Name,
		MangledName: mangledName,
		Node:        fn,
	})
	...
}
</code></pre>
<p>虽然目前还不支持调用自定义函数，但是有了Scope之后自定义的函数已经可以通过名字查询到了。</p>
<h2 id="437-定义局部变量"><a class="header" href="#437-定义局部变量">4.3.7 定义局部变量</a></h2>
<p>Compiler对象的compileStmt方法用于编译语句，在其中增加对<code>*ast.VarSpec</code>变量定义的处理：</p>
<pre><code class="language-go">func (p *Compiler) compileStmt(w io.Writer, stmt ast.Stmt) {
	switch stmt := stmt.(type) {
	case *ast.VarSpec:
		var localName = &quot;0&quot;
		if stmt.Value != nil {
			localName = p.compileExpr(w, stmt.Value)
		}

		var mangledName = fmt.Sprintf(&quot;%%local_%s.pos.%d&quot;, stmt.Name.Name, stmt.VarPos)
		p.scope.Insert(&amp;Object{
			Name:        stmt.Name.Name,
			MangledName: mangledName,
			Node:        stmt,
		})

		fmt.Fprintf(w, &quot;\t%s = alloca i32, align 4\n&quot;, mangledName)
		fmt.Fprintf(
			w, &quot;\tstore i32 %s, i32* %s\n&quot;,
			localName, mangledName,
		)
	...
	}
}
</code></pre>
<p>需要注意的是，如果变量定义有初始化表达式，一定要先编译表达式。比如在处理<code>var x = x</code>变量定义时，先编译右边表达式则x获取的是外层的定义（因为此时左边的x尚未定义）。处理完右边的初始化表达式之后，再将左边的变量添加到Scope中。然后通过LLVM的alloca指令在栈上分配空间，并进行初始化（如果没有初始化表达式则用0初始化）。</p>
<h2 id="438-变量标识符检索"><a class="header" href="#438-变量标识符检索">4.3.8 变量标识符检索</a></h2>
<p>在处理内置函数调用时我们已经见识过基于Scope的名字检索。对于变量我们只需要增加<code>*ast.Ident</code>类型的表达式处理即可：</p>
<pre><code class="language-go">func (p *Compiler) compileExpr(w io.Writer, expr ast.Expr) (localName string) {
	switch expr := expr.(type) {
	case *ast.Ident:
		var varName string
		if _, obj := p.scope.Lookup(expr.Name); obj != nil {
			varName = obj.MangledName
		} else {
			panic(fmt.Sprintf(&quot;var %s undefined&quot;, expr.Name))
		}

		localName = p.genId()
		fmt.Fprintf(w, &quot;\t%s = load i32, i32* %s, align 4\n&quot;,
			localName, varName,
		)
		return localName
	...
	}
}
</code></pre>
<p><code>p.scope.Lookup(expr.Name)</code>根据名字查询LLVM汇编中对应的局部变量的名字，然后通过LLVM的load指令加载到一个新的变量并返回。</p>
<h2 id="439-赋值变量"><a class="header" href="#439-赋值变量">4.3.9 赋值变量</a></h2>
<p>赋值变量和变量读取到机制差不多，第一步都是要从Scope查询被赋值变量对应的LLVM的名字。compileStmt方法增加对<code>*ast.AssignStmt</code>赋值语句的处理：</p>
<pre><code class="language-go">func (p *Compiler) compileStmt(w io.Writer, stmt ast.Stmt) {
	switch stmt := stmt.(type) {
	...
	case *ast.AssignStmt:
		var varName string
		if _, obj := p.scope.Lookup(stmt.Target.Name); obj != nil {
			varName = obj.MangledName
		} else {
			panic(fmt.Sprintf(&quot;var %s undefined&quot;, stmt.Target.Name))
		}

		localName := p.compileExpr(w, stmt.Value)
		fmt.Fprintf(
			w, &quot;\tstore i32 %s, i32* %s\n&quot;,
			localName, varName,
		)
	...
	}
}
</code></pre>
<p>查询到LLVM对应的变量名之后，通过LLVM的store指令赋值。</p>
<h2 id="4310-全局变量的初始化"><a class="header" href="#4310-全局变量的初始化">4.3.10 全局变量的初始化</a></h2>
<p>到此我们已经基本完成了嵌套变量的支持，现在还需要对全局变量的初始化增加支持。全局变量的初始化语句需要放入一个init函数，builtin包做以下调整：</p>
<pre><code class="language-go">const MainMain = `
define i32 @main() {
	call i32() @ugo_main_init()
	call i32() @ugo_main_main()
	ret i32 0
}
`
</code></pre>
<p>在main函数调用<code>@ugo_main_main()</code>之前先调用<code>@ugo_main_init()</code>进行初始化。</p>
<p>Compiler对象增加genInit方法用于生成全局变量初始化的代码：</p>
<pre><code class="language-go">func (p *Compiler) genInit(w io.Writer, file *ast.File) {
	fmt.Fprintf(w, &quot;define i32 @ugo_%s_init() {\n&quot;, file.Pkg.Name)

	for _, g := range file.Globals {
		var localName = &quot;0&quot;
		if g.Value != nil {
			localName = p.compileExpr(w, g.Value)
		}

		var varName string
		if _, obj := p.scope.Lookup(g.Name.Name); obj != nil {
			varName = obj.MangledName
		} else {
			panic(fmt.Sprintf(&quot;var %s undefined&quot;, g))
		}

		fmt.Fprintf(w, &quot;\tstore i32 %s, i32* %s\n&quot;, localName, varName)
	}
	fmt.Fprintln(w, &quot;\tret i32 0&quot;)
	fmt.Fprintln(w, &quot;}&quot;)
}
</code></pre>
<p>然后在compileFile方法完成全局变量定义之后生成用于初始化的init函数：</p>
<pre><code class="language-go">func (p *Compiler) compileFile(w io.Writer, file *ast.File) {
	...
	for _, g := range file.Globals {}
	p.genInit(w, file)
	...
}
</code></pre>
<h2 id="4311-测试"><a class="header" href="#4311-测试">4.3.11 测试</a></h2>
<p>构造测试用例：</p>
<pre><code class="language-go">package main

var x1 int
var x2 int = 134

func main() {
	{
		var x2 = x2
		x2 = x2 + 1000
		println(x2)
	}
	println(x1)
	println(x2)
}
</code></pre>
<p>蔬菜结果如下：</p>
<pre><code>$ go run main.go -debug=true run ./_examples/hello.ugo
1134
0
134
</code></pre>
<p>结果正常。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="44-输出wasm模块"><a class="header" href="#44-输出wasm模块">4.4 输出WASM模块</a></h1>
<p>我们的后端输出的是LLVM汇编代码。从LLVM-8之后内置了对WebAssembly的支持，因此我们可以借助LLVM工具链产生WASM模块。</p>
<p>根据Ending定律：所有可以用WebAssembly实现的终将会用WebAssembly实现（<em>Ending's law: &quot;Any application that can be compiled to WebAssembly, will be compiled to WebAssembly eventually.&quot;</em>）。因此uGo也必然要支持WebAssembly。</p>
<p>WebAssembly的基础知识可以参考作者的《WebAssembly标准入门》：</p>
<p><img src="ch4-block-and-var/../images/wasm-book.jpg" alt="" /></p>
<h2 id="441-导入builtin函数"><a class="header" href="#441-导入builtin函数">4.4.1 导入Builtin函数</a></h2>
<p>之前是基于C语言构造了Builtin的println和exit函数，在WASM环境我们可以从宿主导入。可以基于Node.js构造宿主需要的函数：</p>
<pre><code class="language-js">// run_wasm.js
const fs = require('fs');

var wasmInstance = null

WebAssembly.instantiate(
	new Uint8Array(fs.readFileSync('./a.out.wasm')),
	{
		env: {
			ugo_builtin_println: function(n) {
				console.log(n);
				return 0;
			},
			ugo_builtin_exit: function(n) {
				console.log(&quot;exit:&quot;, n);
				return 0;
			}
		}
	}
).then(result =&gt; {
	wasmInstance = result.instance;
	wasmInstance.exports.main();
}).catch(e =&gt; {
	console.log(e);
});
</code></pre>
<p>其中分别定义了ugo_builtin_println和ugo_builtin_exit两个函数。</p>
<h2 id="442-配置wasm工具链"><a class="header" href="#442-配置wasm工具链">4.4.2 配置WASM工具链</a></h2>
<p>从LLVM-IR到WASM可以通过llc和wasm-ld两个命令完成，这2个文件只有在安装LLVM-8之后的版本才可用。为了方便指定这些工具，main函数新增对应2个参数：</p>
<pre><code class="language-go">func main() {
	...
	app.Flags = []cli.Flag{
		...
		&amp;cli.StringFlag{Name: &quot;wasm-llc&quot;, Value: &quot;&quot;, Usage: &quot;set wasm-llc&quot;},
		&amp;cli.StringFlag{Name: &quot;wasm-ld&quot;, Value: &quot;&quot;, Usage: &quot;set wasm-ld&quot;},
		...
	}
	...
}
</code></pre>
<p>同时build的参数也增加相应的配置：</p>
<pre><code class="language-go">package build

type Option struct {
	...
	WasmLLC string
	WasmLD  string
}
</code></pre>
<p>同样完善在main需要的辅助函数：</p>
<pre><code class="language-go">func build_Options(c *cli.Context) *build.Option {
	return &amp;build.Option{
		...
		WasmLLC: c.String(&quot;wasm-llc&quot;),
		WasmLD:  c.String(&quot;wasm-ld&quot;),
	}
}
</code></pre>
<p>llc和wasm-ld命令就绪后就可以准备后续工作了。</p>
<h2 id="443-配置wasm工具链"><a class="header" href="#443-配置wasm工具链">4.4.3 配置WASM工具链</a></h2>
<p>改造build包中的<code>Context.build</code>方法，增加对wasm的特化处理：</p>
<pre><code class="language-go">package build

func (p *Context) build(
	filename string, src interface{}, outfile, goos, goarch string,
) (output []byte, err error) {
	...
	if p.opt.GOOS == &quot;wasm&quot; {
		if !strings.HasSuffix(outfile, &quot;.wasm&quot;) {
			outfile += &quot;.wasm&quot;
		}

		cmdLLC := exec.Command(
			p.opt.WasmLLC,
			&quot;-march=wasm32&quot;,
			&quot;-filetype=obj&quot;,
			&quot;-o&quot;, _a_out_ll_o,
			_a_out_ll,
		)
		if data, err := cmdLLC.CombinedOutput(); err != nil {
			return data, err
		}

		cmdWasmLD := exec.Command(
			p.opt.WasmLD,
			&quot;--entry=main&quot;,
			&quot;--allow-undefined&quot;,
			&quot;--export-all&quot;,
			_a_out_ll_o,
			&quot;-o&quot;, outfile,
		)
		data, err := cmdWasmLD.CombinedOutput()
		return data, err
	}
	...
}
</code></pre>
<p>基本思路是先用llc产生wasm32平台的obj文件，然后通过wasm-ld将obj文件链接为wasm文件。</p>
<h2 id="444-组装测试"><a class="header" href="#444-组装测试">4.4.4 组装测试</a></h2>
<p>依然是之前的例子(<code>./_examples/hello.ugo</code>)：</p>
<pre><code class="language-go">package main

var x1 int
var x2 int = 134

func main() {
	{
		var x2 = x2
		x2 = x2 + 1000
		println(x2)
	}
	println(x1)
	println(x2)
}
</code></pre>
<p>作者本地LLVM-9安装在<code>/usr/local/Cellar</code>路径，通过以下命令构建wasm模块：</p>
<pre><code>$ go run main.go \
	-goos=wasm -debug=true \
	-wasm-llc=/usr/local/Cellar/llvm/9.0.0/bin/llc \
	-wasm-ld=/usr/local/Cellar/llvm/9.0.0/bin/wasm-ld \
	build ./_examples/hello.ugo

</code></pre>
<p>输出的wasm文件可以用<code>wasm2wat a.out.wasm</code>命令查看：</p>
<pre><code class="language-webassembly">(module
  (type (;0;) (func (param i32) (result i32)))
  (type (;1;) (func))
  (type (;2;) (func (result i32)))
  (type (;3;) (func (param i32 i32) (result i32)))
  (import &quot;env&quot; &quot;ugo_builtin_println&quot; (func $ugo_builtin_println (type 0)))
  (func $__wasm_call_ctors (type 1))
  (func $ugo_main_main (type 2) (result i32)
    (local i32 i32)
    get_global 0
    i32.const 16
    i32.sub
    tee_local 0
    set_global 0
    get_local 0
    i32.const 0
    i32.load offset=1028
    i32.const 1000
    i32.add
    tee_local 1
    i32.store offset=12
    get_local 1
    call $ugo_builtin_println
    drop
    i32.const 0
    i32.load offset=1024
    call $ugo_builtin_println
    drop
    i32.const 0
    i32.load offset=1028
    call $ugo_builtin_println
    drop
    get_local 0
    i32.const 16
    i32.add
    set_global 0
    i32.const 0)
  (func $ugo_main_init (type 2) (result i32)
    i32.const 0
    i32.const 134
    i32.store offset=1028
    i32.const 0
    i32.const 0
    i32.store offset=1024
    i32.const 0)
  (func $__original_main (type 2) (result i32)
    call $ugo_main_init
    drop
    call $ugo_main_main
    drop
    i32.const 0)
  (func $main (type 3) (param i32 i32) (result i32)
    call $__original_main)
  (table (;0;) 1 1 anyfunc)
  (memory (;0;) 2)
  (global (;0;) (mut i32) (i32.const 66576))
  (global (;1;) i32 (i32.const 1032))
  (global (;2;) i32 (i32.const 1024))
  (global (;3;) i32 (i32.const 66576))
  (global (;4;) i32 (i32.const 1024))
  (global (;5;) i32 (i32.const 1028))
  (global (;6;) i32 (i32.const 1024))
  (export &quot;memory&quot; (memory 0))
  (export &quot;__wasm_call_ctors&quot; (func $__wasm_call_ctors))
  (export &quot;__data_end&quot; (global 1))
  (export &quot;__global_base&quot; (global 2))
  (export &quot;__heap_base&quot; (global 3))
  (export &quot;__dso_handle&quot; (global 4))
  (export &quot;ugo_main_main&quot; (func $ugo_main_main))
  (export &quot;ugo_main_x2&quot; (global 5))
  (export &quot;ugo_main_x1&quot; (global 6))
  (export &quot;ugo_main_init&quot; (func $ugo_main_init))
  (export &quot;__original_main&quot; (func $__original_main))
  (export &quot;main&quot; (func $main))
  (data (i32.const 1024) &quot;\00\00\00\00\00\00\00\00&quot;))
</code></pre>
<p>现在可以通过Node.js执行了：</p>
<pre><code>$ node run_wasm.js
1134
0
134
</code></pre>
<p>输出结果和本地执行一致。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="45-简短定义和多赋值"><a class="header" href="#45-简短定义和多赋值">4.5 简短定义和多赋值</a></h1>
<p>简短定义和多赋值是Go中最常用的语法糖，类似<code>x2, x3 := x2+1, 1+2</code>这种语法，本节我们将实现这个特性。</p>
<h2 id="451-完善token包"><a class="header" href="#451-完善token包">4.5.1 完善token包</a></h2>
<p>简短定义和多赋值出现了2个新的Token类型：<code>:=</code>和<code>,</code>。token包增加相应的定义：</p>
<pre><code class="language-go">const (
	EOF TokenType = iota // = 0
	...
	DEFINE // :=
	COMMA  // ,
	...
)

var tokens = [...]string{
	DEFINE: &quot;:=&quot;,
	COMMA:  &quot;,&quot;,
}
</code></pre>
<p>其他定义保持不变。</p>
<h2 id="452-完善lexer"><a class="header" href="#452-完善lexer">4.5.2 完善lexer</a></h2>
<p>Token的解析可以看作是简化版本的语法解析，在switch扩展相应的case即可：</p>
<pre><code class="language-go">func (p *Lexer) run() (tokens []token.Token) {
	...
	for {
		r := p.src.Read()
		...

		switch {
		case r == ':': // :, :=
			switch p.src.Read() {
			case '=':
				p.emit(token.DEFINE)
			default:
				p.errorf(&quot;unrecognized character: %#U&quot;, r)
			}
		case r == ',':
			p.emit(token.COMMA)
		...
		}
	}
}
</code></pre>
<p>完成后可以自行通过<code>go run main.go lex file.ugo</code>命令测试。</p>
<h2 id="453-完善astassignstmt"><a class="header" href="#453-完善astassignstmt">4.5.3 完善<code>ast.AssignStmt</code></a></h2>
<p>修改如下：</p>
<pre><code class="language-go">type AssignStmt struct {
	Target []*Ident        // 要赋值的目标
	OpPos  token.Pos       // ':=' 的位置
	Op     token.TokenType // '=' or ':='
	Value  []Expr          // 值
}
</code></pre>
<p>将<code>Target</code>和<code>Value</code>属性改成了切片以支持多赋值。如果<code>Op</code>为<code>token.DEFINE</code>类型则表示简短定义。</p>
<h2 id="454-完善语法解析"><a class="header" href="#454-完善语法解析">4.5.4 完善语法解析</a></h2>
<p>新增多表达式的解析方法：</p>
<pre><code class="language-go">// x, y :=
func (p *Parser) parseExprList() (exprs []ast.Expr) {
	for {
		exprs = append(exprs, p.parseExpr())
		if p.PeekToken().Type != token.COMMA {
			break
		}
		p.ReadToken()
	}
	return
}
</code></pre>
<p>然后调整<code>Parser.parseStmt_block</code>方法：</p>
<pre><code class="language-go">func (p *Parser) parseStmt_block() *ast.BlockStmt {
	...
Loop:
	for {
		...
		switch tok := p.PeekToken(); tok.Type {
		...
		default:
			// exprList ;
			// exprList := exprList;
			// exprList = exprList;
			exprList := p.parseExprList()
			switch tok := p.PeekToken(); tok.Type {
			case token.SEMICOLON:
				if len(exprList) != 1 {
					p.errorf(tok.Pos, &quot;unknown token: %v&quot;, tok.Type)
				}
				block.List = append(block.List, &amp;ast.ExprStmt{
					X: exprList[0],
				})
			case token.DEFINE, token.ASSIGN:
				p.ReadToken()
				exprValueList := p.parseExprList()
				if len(exprList) != len(exprValueList) {
					p.errorf(tok.Pos, &quot;unknown token: %v&quot;, tok)
				}
				var assignStmt = &amp;ast.AssignStmt{
					Target: make([]*ast.Ident, len(exprList)),
					OpPos:  tok.Pos,
					Op:     tok.Type,
					Value:  make([]ast.Expr, len(exprList)),
				}
				for i, target := range exprList {
					assignStmt.Target[i] = target.(*ast.Ident)
					assignStmt.Value[i] = exprValueList[i]
				}
				block.List = append(block.List, assignStmt)
			default:
				p.errorf(tok.Pos, &quot;unknown token: %v&quot;, tok)
			}
		}
	}
	...
}
</code></pre>
<p>将之前的单赋值解析改造为多赋值解析，并支持简短定义。</p>
<h2 id="455-完善代码生成"><a class="header" href="#455-完善代码生成">4.5.5 完善代码生成</a></h2>
<p><code>ast.AssignStmt</code>节点的翻译在<code>Compiler.compileStmt</code>方法，改造后的代码：</p>
<pre><code class="language-go">func (p *Compiler) compileStmt(w io.Writer, stmt ast.Stmt) {
	switch stmt := stmt.(type) {
	case *ast.AssignStmt:
		var valueNameList = make([]string, len(stmt.Value))
		for i := range stmt.Target {
			valueNameList[i] = p.compileExpr(w, stmt.Value[i])
		}

		if stmt.Op == token.DEFINE {
			for _, target := range stmt.Target {
				if _, obj := p.scope.Lookup(target.Name); obj == nil {
					var mangledName = fmt.Sprintf(&quot;%%local_%s.pos.%d&quot;, target.Name, target.NamePos)
					p.scope.Insert(&amp;Object{
						Name:        target.Name,
						MangledName: mangledName,
						Node:        target,
					})
					fmt.Fprintf(w, &quot;\t%s = alloca i32, align 4\n&quot;, mangledName)
				}
			}
		}
		for i := range stmt.Target {
			var varName string
			if _, obj := p.scope.Lookup(stmt.Target[i].Name); obj != nil {
				varName = obj.MangledName
			} else {
				panic(fmt.Sprintf(&quot;var %s undefined&quot;, stmt.Target[0].Name))
			}

			fmt.Fprintf(
				w, &quot;\tstore i32 %s, i32* %s\n&quot;,
				valueNameList[i], varName,
			)
		}
	...
	}
</code></pre>
<p>首先计算右侧的表达式列表（记住不能先处理表达式左边的目标）。然后判断是否为简短定义，如果是并且赋值的目标在当前Scope没有定义则定义新的局部变量（全局变量不支持简短定义）。最后处理表达式左边的目标，将右边的值依次保存到目标中。</p>
<h2 id="456-测试"><a class="header" href="#456-测试">4.5.6 测试</a></h2>
<p>构造以下测试代码：</p>
<pre><code class="language-go">package main

var x1 int
var x2 int = 134

func main() {
	{
		x2, x3 := x2+1, 456
		println(x2)
		println(x3)
	}
	println(x1)
	println(x2)
}
</code></pre>
<p>执行结果如下：</p>
<pre><code>$ go run main.go run ./_examples/hello.ugo 
135
456
0
135
</code></pre>
<p>结果正常。</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="5-if分支和for循环"><a class="header" href="#5-if分支和for循环">5. if分支和for循环</a></h1>
<p>for循环的例子：</p>
<pre><code class="language-go">package main

func main() {
	for i := 5; i &lt; 10; i = i + 1 {
		println(i)
	}
}
</code></pre>
<p>执行：</p>
<pre><code>$ go run main.go run ./_examples/hello.ugo
5
6
7
8
9
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="51-完善token包和lex包"><a class="header" href="#51-完善token包和lex包">5.1 完善token包和lex包</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="52-完善ast和解析器"><a class="header" href="#52-完善ast和解析器">5.2 完善AST和解析器</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="53-if分支到llir汇编"><a class="header" href="#53-if分支到llir汇编">5.3 if分支到LLIR汇编</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="54-for分支到llir汇编"><a class="header" href="#54-for分支到llir汇编">5.4 for分支到LLIR汇编</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="55-打印1到100的素数"><a class="header" href="#55-打印1到100的素数">5.5 打印1到100的素数</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="6-函数和递归"><a class="header" href="#6-函数和递归">6. 函数和递归</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="7-多文件和多包支持"><a class="header" href="#7-多文件和多包支持">7. 多文件和多包支持</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="8-字符串"><a class="header" href="#8-字符串">8. 字符串</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="9-数组"><a class="header" href="#9-数组">9. 数组</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="10-map"><a class="header" href="#10-map">10. map</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="11-结构体"><a class="header" href="#11-结构体">11. 结构体</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="12-方法"><a class="header" href="#12-方法">12. 方法</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="13-闭包"><a class="header" href="#13-闭包">13. 闭包</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="14-接口"><a class="header" href="#14-接口">14. 接口</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="15-异常"><a class="header" href="#15-异常">15. 异常</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="16-反射"><a class="header" href="#16-反射">16. 反射</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="17-cgo"><a class="header" href="#17-cgo">17. CGO</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="18-wasm"><a class="header" href="#18-wasm">18. WASM</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="19-类型系统"><a class="header" href="#19-类型系统">19. 类型系统</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="20-自举"><a class="header" href="#20-自举">20. 自举</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="21-lsp服务"><a class="header" href="#21-lsp服务">21. LSP服务</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="附录"><a class="header" href="#附录">附录</a></h1>
<h2 id="llvm-参考"><a class="header" href="#llvm-参考">LLVM 参考</a></h2>
<h3 id="标识符"><a class="header" href="#标识符">标识符</a></h3>
<p>LLIR中命名标识符有两种：全局标识符、局部标识符。命名的标识符命名规则是：<code>[@%][a-zA-Z$._][a-zA-Z$._0-9]*</code>，以<code>@</code>开头的是全局标识符，以<code>%</code>开头的是局部标识符。</p>
<h4 id="全局标识符"><a class="header" href="#全局标识符">全局标识符</a></h4>
<p>全局标识符主要用于表示全局的变量或常量，还有全局函数的命名。下面是全局标识符的一些例子：</p>
<pre><code class="language-llvm">@count = global i32 21
@hello = internal constant [6 x i8] c&quot;hello\00&quot;

declare i32 @puts(i8* nocapture) nounwind

define void @main() {
	ret void
}
</code></pre>
<p>其中<code>@count</code>是一个全局的变量，类型是<code>i32</code>，初始值为21；<code>@hello</code>是一个内部的字符串常量；<code>@puts</code>是外部导入的函数名；<code>@main</code>是新定义的函数名。</p>
<p>因为<code>$.</code>都是合法的标识符名称，可以通过<code>$.</code>来为全局的标识符构造不同层级的名字空间。比如下面的例子：</p>
<pre><code class="language-llvm">@main.count = global i32 21
@std.math.pi = global double 3.14

@main.count.$type = ....
</code></pre>
<p>其中<code>@main.count</code>可以表示为<code>main</code>包下面的<code>count</code>全局变量，而<code>@std.math.pi</code>可以表示为<code>std.math</code>包下面的<code>pi</code>变量。最后的<code>@main.count.$type</code>带有<code>$</code>字符，可以用户表示和<code>count</code>全局变量相关的其它信息。</p>
<p>关于全局变量的其它细节可以暂时忽略，在后文会详细解释。</p>
<h4 id="局部标识符"><a class="header" href="#局部标识符">局部标识符</a></h4>
<p>除了全局标识符之外还有局部标识符。局部标识符主要用于表示函数的参数和函数内局部变量（局部变量可以对应未寄存器）。下面是局部标识符的一些例子：</p>
<pre><code class="language-llvm">define i32 @main(i32 %argc, i8** %argv) nounwind {
	ret i32 0
}
</code></pre>
<p>其中<code>%argc</code>和<code>%argv</code>都是以<code>%</code>开头表示局部变量，对应<code>@main</code>函数的两个输出参数。</p>
<p>也可以通过<code>$.</code>来为布局的标识符构造不同层级的名字空间。比如下面的例子：</p>
<pre><code class="language-llvm">define i32 @main() {
	%str.addr = getelementptr [6 x i8],[6 x i8]* @&quot;hello\0a&quot;, i64 0, i64 0
	ret i32 0
}
</code></pre>
<p><code>%str.addr</code>可以用于表示字符串中的地址属性。</p>
<h4 id="未命名标识符"><a class="header" href="#未命名标识符">未命名标识符</a></h4>
<p>除了命名的标识符之外，还有未命名的标识符，它们以无符号的数字表示：</p>
<pre><code class="language-llvm">@0 = global i32 100
@1 = global i32 200
@2 = global i32 300

define void @main() {
	%1 = load i32, i32* @0
	ret void
}
</code></pre>
<p>其中<code>@0</code>/<code>@1</code>/<code>@2</code>分别是三个未命名的全局标识符，对应三个<code>i32</code>类型的全局变量。而<code>@main</code>函数内部的<code>%1</code>表示一个局部的未命名标识符，可以理解为一个寄存器。</p>
<p>在LLVM8中，全局的未命名标识符好像必须从<code>@0</code>开始编号，局部的未命名标识符好像必须从<code>%1</code>开始编号，具体原因还有待分析。</p>
<h4 id="特殊字符"><a class="header" href="#特殊字符">特殊字符</a></h4>
<p>在标识符还可以通过转义字符的方式表示任意的特殊字符：</p>
<pre><code class="language-llvm">@&quot;hello\0a&quot; = internal constant [6 x i8] c&quot;hello\00&quot;
</code></pre>
<p>如果标识符有转义字符存在则必须用双引号包围起来，比如<code>@&quot;hello\0a&quot;</code>。转义字符串的格式为<code>\xx</code>，其中<code>xx</code>是十六进制表达的ASCII值，比如<code>\0a</code>表示换行符<code>\n</code>。几乎可以使用任意的Unicode字符来命名标识符，只要用UTF8编码后再用转义字符就可以表示了。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
